<!DOCTYPE html>
<!--
    Web Toothbrush Inspector
    Copyright (c) 2025 @printminion
    Licensed under the MIT License - see LICENSE file for details
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Toothbrush Inspector for Sonicare Toothbrush by @printminion</title>
    <!-- 1. Tailwind CSS -->
    <script src="lib/tailwind.js"></script>
    <!-- 2. Chart.js for graphs -->
    <script src="lib/chart.js"></script>
    <!-- 3. Three.js for 3D visualization -->
    <script type="importmap">
    {
        "imports": {
            "three": "./lib/three/three.module.js",
            "three/addons/": "./lib/three/addons/"
        }
    }
    </script>
    <style>
        /* Deep dark mode theme */
        :root {
            --gray-950: #0a0a0f;
            --gray-900: #111827;
            --gray-850: #1a1f2e;
            --gray-800: #1f2937;
            --gray-750: #283142;
            --blue-500: #3b82f6;
            --blue-600: #2563eb;
            --green-500: #10b981;
            --yellow-500: #f59e0b;
            --red-500: #ef4444;
        }

        /* Simple dark mode */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--gray-950);
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--gray-900);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--gray-750);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-800);
        }

        /* Tab Transitions */
        .tab-content {
            transition: opacity 0.2s ease-in-out;
        }
        .tab-btn.active {
            border-bottom: 2px solid #60a5fa; /* blue-400 */
            color: #60a5fa;
            background-color: rgba(96, 165, 250, 0.1);
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        .calibration-step.hidden {
            display: none !important;
        }

        /* Card containers */
        .card {
            background: var(--gray-850);
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
        }

        /* Blur overlay for disconnected state */
        .blur-content {
            filter: blur(4px);
            pointer-events: none;
            user-select: none;
            transition: filter 0.3s ease;
        }

        .blur-content.connected {
            filter: blur(0);
            pointer-events: auto;
            user-select: auto;
        }

        /* Battery bar */
        .battery-bar {
            height: 0.5rem;
            border-radius: 0.25rem;
            transition: width 0.3s ease, background-color 0.3s ease;
        }

        .battery-bar.high {
            background-color: var(--green-500);
        }

        .battery-bar.medium {
            background-color: var(--yellow-500);
        }

        .battery-bar.low {
            background-color: var(--red-500);
        }

        .calibration-step.hidden {
            display: none !important;
        }

        /* Collapsible panel state */
        .collapsed {
            display: none;
        }

        /* Collapse panels by default on mobile devices */
        @media (max-width: 768px) {
            #three-info-content,
            #coordinate-content {
                display: none;
            }
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen flex flex-col">

    <!-- Top Navigation Bar -->
    <nav class="bg-gray-900 border-b border-gray-800 sticky top-0 z-40 shadow-lg">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center gap-3 text-nowrap">
                    <div class="text-5xl">ü™•</div>
                    <div>
                        <h1 class="text-lg font-bold text-white leading-tight">Web Inspector for Sonicare Toothbrush</h1>
                        <p class="text-xs text-gray-400">Real-time data from your toothbrush</p>
                    </div>
                </div>
                <div class="hidden md:flex items-center space-x-4">
                    <!-- GitHub -->
                    <a href="https://github.com/printminion/web-toothbrush-inspector" target="_blank" rel="noopener noreferrer"
                       class="inline-flex items-center gap-2 text-white text-gray-400 hover:text-blue-400 transition text-nowrap">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd" />
                        </svg>
                        <span class="font-medium">GitHub</span>
                    </a>

                    <!-- Twitter/X -->
                    <a href="https://x.com/printminion" target="_blank" rel="noopener noreferrer"
                       class="inline-flex items-center gap-2 text-white text-gray-400 hover:text-green-400 transition text-nowrap">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                        <span class="font-medium">@printminion</span>
                    </a>

                    <!-- Cults3D -->
                    <a href="https://cults3d.com/@printminion" target="_blank" rel="noopener noreferrer"
                       class="inline-flex items-center gap-2 text-white text-gray-400 hover:text-purple-400 transition text-nowrap">
                        <svg xmlns="http://www.w3.org/2000/svg" width="25px" height="25px" fill="currentColor" viewBox="0 0 260 260" role="img" class="w-5 h-5"><title id="adk7sjv3qcdt68qpuduqf62hnhfu2e7i">Cults.</title>
                            <path d="M56.145 84.655c-20.238 13.483-33.613 36.496-33.613 62.586 0 41.448 33.725 75.168 75.167 75.168 12.086 0 23.497-2.879 33.62-7.964l-.021-.011-.13-.068c10.161 5.134 21.63 8.043 33.771 8.043 41.45 0 75.173-33.72 75.173-75.168 0-26.113-13.396-49.149-33.663-62.626-2.059-39.665-34.973-71.3-75.14-71.3-40.106 0-72.977 31.542-75.13 71.118l-.034.222zm17.165-8.664c5.779-26.71 29.585-46.787 58.001-46.787 32.728 0 59.353 26.626 59.353 59.354 0 17.274-7.424 32.845-19.238 43.702l-8.281-4.747-15.918 9.123 25.565 14.658c16.324-10.833 28.196-27.854 32.24-47.693 11.799 10.846 19.203 26.394 19.203 43.642 0 32.695-26.601 59.293-59.297 59.293-28.389 0-52.215-20.051-57.995-46.732l8.458-4.879v-18.245l-25.569 14.694c1.14 20.876 10.864 39.506 25.658 52.447l-.007-.017c-5.621 1.775-11.583 2.731-17.785 2.731-32.696 0-59.292-26.598-59.292-59.293 0-32.696 26.595-59.298 59.292-59.298 6.207 0 12.187.962 17.807 2.734l.037 9.626 15.859 9.063v-29.332c-10-5.084-21.58-7.965-33.661-7.965-8.555 0-16.797 1.443-24.466 4.09l.036-.169z"></path>
                        </svg>
                        <span class="font-medium">3D Enclosures</span>
                    </a>

                    <!-- Buy Me a Coffee -->
                    <a href="https://buymeacoffee.com/printminion" target="_blank" rel="noopener noreferrer"
                       class="inline-flex items-center gap-2 bg-yellow-600 hover:bg-yellow-700 text-black px-4 py-2 rounded-lg transition duration-300 ease-in-out font-bold shadow-lg text-nowrap">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.233-2.416.359-4.866.54-7.308.46-1.748-.06-3.477-.254-5.207-.498-.17-.024-.353-.055-.47-.18-.22-.236-.111-.71-.054-.995.052-.26.152-.609.463-.646.484-.057 1.046.148 1.526.22.577.088 1.156.159 1.737.212 2.48.226 5.002.19 7.472-.14.45-.06.899-.13 1.345-.21.399-.072.84-.206 1.08.206.166.281.188.657.162.974a.544.544 0 01-.169.364z"/>
                        </svg>
                        <span class="font-medium">Buy Me a Coffee</span>
                    </a>
                </div>
            </div>
        </div>
    </nav>

<main class="flex-grow max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8 py-6 relative">
        <!-- Disclaimer -->
        <div class="bg-gray-800/50 border border-gray-600 text-gray-300 px-4 py-3 rounded-lg mb-4 text-xs">
            <strong class="font-semibold">Disclaimer:</strong>
            <span class="block sm:inline">This is an independent, unofficial, open-source project. It is not affiliated with, endorsed by, or sponsored by Koninklijke Philips N.V. or any of its "Sonicare" branded products.
                All trademarks, logos, and brand names are the property of their respective owners.
            </span>
        </div>

        <!-- Status & Instructions -->
        <div class="card p-6 mb-6">
            <div class="flex justify-between flex-wrap gap-4">
                <div class="flex items-center">
                    <button id="connect-button" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform text-nowrap flex items-center">
                        <span class="mr-2 text-xl">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                                <rect width="15.738" height="24" x="4.131" fill="#0a3d91" ry="7.156" style="stroke-width:.0245902"/>
                                <path fill="none" stroke="#fff" stroke-width="1.303" d="m8.034 7.862 7.5 7.55-3.614 4.376V4.15l3.614 4.18-7.5 7.353"/>
                            </svg>
                        </span>
                        Connect your toothbrush
                    </button>
                </div>
                <div class="flex grow items-center gap-3">
                    <!-- Connection Instructions -->
                    <div id="connection-instructions" class="grow p-4 bg-gray-800/50 rounded-lg">
                        <p class="text-sm text-blue-200">
                            <strong class="font-semibold">BEST METHOD:</strong> üîå Place toothbrush on charger (LED should light up) ‚Üí Click Connect ‚Üí Select device
                        </p>
                        <p class="text-xs text-gray-400 mt-1">Alternative: Press power button ‚Üí immediately click Connect</p>
                    </div>
                </div>
            </div>

            <!-- Status Message -->
            <div id="status-alert" class="mt-4 p-4 rounded-lg relative" role="alert">
                <p id="status-message" class="text-sm font-semibold">Status: Not Connected</p>
                <div id="connection-progress" class="hidden mt-2">
                    <div class="flex justify-between items-center mb-1">
                        <span id="progress-text" class="text-xs text-gray-400">Connecting...</span>
                        <span id="countdown-timer" class="text-xs text-gray-400"></span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2.5">
                        <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content Grid -->
        <!-- The 'blur-content' class is removed by JS when connected -->
    <div id="dashboard-content" class="grid grid-cols-1 lg:grid-cols-3 gap-6 blur-content">
        <!-- Column 1: Data Panel with Tabs -->
        <div class="lg:col-span-1 flex flex-col h-[800px]"> <!-- Fixed height for alignment -->
            <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-lg flex flex-col h-full overflow-hidden">

                <!-- Tabs Header -->
                <div class="flex border-b border-gray-700 bg-gray-850">
                    <button class="tab-btn active flex-1 py-3 text-sm font-medium text-gray-300 hover:text-white transition text-center focus:outline-none"
                            data-tab="live">
                        Live
                    </button>
                    <button class="tab-btn flex-1 py-3 text-sm font-medium text-gray-300 hover:text-white transition text-center focus:outline-none"
                            data-tab="device">
                        Device
                    </button>
                    <button class="tab-btn flex-1 py-3 text-sm font-medium text-gray-300 hover:text-white transition text-center focus:outline-none"
                            data-tab="brush">
                        Brush
                    </button>
                    <button class="tab-btn flex-1 py-3 text-sm font-medium text-gray-300 hover:text-white transition text-center focus:outline-none"
                            data-tab="debug">
                        Debug
                    </button>
                </div>

                <!-- Tab Content Area -->
                <div class="p-0 flex-grow overflow-y-auto custom-scrollbar relative">
                    <!-- TAB 1: LIVE DATA -->
                    <div id="tab-live" class="tab-content p-4 space-y-3 absolute inset-0 overflow-y-auto active">
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">Real-time Telemetry</h3>

                        <!-- Battery Card -->
                        <div class="bg-gray-750 p-4 rounded-lg border border-gray-600">
                            <div class="flex justify-between items-end mb-2">
                                <span class="text-sm text-gray-400">Battery Level</span>
                                <span id="data-battery" class="text-xl font-bold text-white">-- %</span>
                            </div>
                            <div class="w-full bg-gray-900 rounded-full h-2.5">
                                <div id="visual-battery-bar" class="battery-bar bg-green-500 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>

                        <!-- Primary States -->
                        <div class="grid grid-cols-2 gap-3">
                            <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                                <div class="text-xs text-gray-400 mb-1">Handle State</div>
                                <div id="data-handle-state" class="font-bold text-white text-lg">---</div>
                            </div>
                            <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                                <div class="text-xs text-gray-400 mb-1">Mode</div>
                                <div id="data-mode" class="font-bold text-blue-300 text-lg truncate">---</div>
                            </div>
                        </div>
                        <!-- Secondary Metrics -->
                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600 space-y-3">
                            <div class="flex justify-between border-b border-gray-600 pb-2">
                                <span class="text-sm text-gray-400">Active Time</span>
                                <span id="data-active-time" class="font-mono font-bold text-white">---</span>
                            </div>
                            <div class="flex justify-between border-b border-gray-600 pb-2">
                                <span class="text-sm text-gray-400">Strength</span>
                                <span id="data-strength" class="font-mono font-bold text-white">---</span>
                            </div>
                            <div class="flex justify-between border-b border-gray-600 pb-2">
                                <span class="text-sm text-gray-400">Pressure</span>
                                <span id="data-pressure-sensor" class="font-mono font-bold text-red-300">---</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-sm text-gray-400">Session State</span>
                                <span id="data-session-state" class="font-mono font-bold text-white">---</span>
                            </div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                            <div class="text-xs text-gray-400 mb-1">Routine Info</div>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>ID: <span id="data-routine-id" class="text-white font-bold">--</span></div>
                                <div>#: <span id="data-routine-number" class="text-white font-bold">--</span></div>
                            </div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                            <div class="text-xs text-gray-400">Handle Time</div>
                            <div id="data-handle-time" class="text-sm font-mono text-white mt-1">---</div>
                        </div>

                         <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                            <div class="text-xs text-gray-400">Motor Runtime</div>
                            <div id="data-motor-runtime" class="text-sm font-mono text-white mt-1">---</div>
                        </div>
                    </div>
                    <!-- TAB 2: DEVICE INFO -->
                    <div id="tab-brush" class="tab-content hidden p-4 space-y-3 absolute inset-0 overflow-y-auto">
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">Smart Head Info</h3>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600 border-l-4 border-l-green-500">
                            <div class="text-xs text-gray-400">Type</div>
                            <div id="data-brush-type" class="font-bold text-white text-lg">---</div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600 space-y-2">
                            <div class="flex justify-between items-center">
                                <span class="text-xs text-gray-400">Total Usage</span>
                                <span id="data-brush-usage" class="font-bold text-white">---</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-xs text-gray-400">Lifetime Limit</span>
                                <span id="data-lifetime-limit" class="text-gray-300">---</span>
                            </div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                            <div class="text-xs text-gray-400 mb-1">Serial (Hex)</div>
                            <div id="data-brush-serial" class="font-mono text-xs text-green-300 break-all">---</div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600">
                            <div class="text-xs text-gray-400 mb-1">NFC URL</div>
                            <div id="data-brush-head-nfc-url" class="text-xs break-all text-blue-400">---</div>
                        </div>

                        <!-- Collapsible Advanced Brush Info -->
                        <details class="group">
                            <summary class="flex justify-between items-center font-medium cursor-pointer list-none text-xs text-gray-500 hover:text-white transition">
                                <span>Advanced NFC Data</span>
                                <span class="transition group-open:rotate-180">
                                    <svg fill="none" height="20" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="20"><path d="M6 9l6 6 6-6"></path></svg>
                                </span>
                            </summary>
                            <div class="text-xs text-gray-400 mt-2 space-y-2 pl-2 border-l border-gray-700">
                                <p>Tag Ver: <span id="data-nfc-tag-version" class="text-gray-300">---</span></p>
                                <p>Factory: <span id="data-factory-mode" class="text-gray-300">---</span></p>
                                <p>4270: <span id="data-brush-head-4270" class="break-all">---</span></p>
                                <p>4280: <span id="data-brush-head-4280" class="break-all">---</span></p>
                                <p>42A2: <span id="data-brush-head-42a2" class="break-all">---</span></p>
                                <p>42A4: <span id="data-brush-head-42a4" class="break-all">---</span></p>
                                <p>42A6: <span id="data-brush-head-42a6" class="break-all">---</span></p>
                                <p>42C0: <span id="data-brush-head-42c0" class="break-all">---</span></p>
                            </div>
                        </details>
                    </div>
                    <!-- TAB 3: BRUSH HEAD -->
                    <div id="tab-debug" class="tab-content hidden p-4 space-y-3 absolute inset-0 overflow-y-auto">
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">Raw Diagnostic Data</h3>

                        <div class="space-y-2 text-xs font-mono">
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-red-400">Error (Persistent):</span> <span id="data-error-persistent">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-orange-400">Error (Volatile):</span> <span id="data-error-volatile">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-blue-400">Sensor Config:</span> <span id="data-sensor-config">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-gray-400">System ID:</span> <span id="data-system-id" class="break-all">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-gray-400">PnP ID:</span> <span id="data-pnp-id" class="break-all">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-gray-400">Proximity:</span> <span id="data-proximity-value">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-gray-400">Inv. Charger:</span> <span id="data-invalid-charger-count">---</span>
                            </div>
                            <div class="bg-black/30 p-2 rounded border border-gray-700">
                                <span class="text-gray-400">IEEE Reg:</span> <span id="data-ieee-regulatory" class="break-all">---</span>
                            </div>
                        </div>

                        <div class="mt-4">
                            <div class="text-xs text-gray-500 mb-1">Last Debug Packet:</div>
                            <div id="data-debug-info" class="bg-black p-2 rounded text-xs font-mono text-green-500 h-20 overflow-y-auto border border-gray-700">---</div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg mt-4">
                            <div class="text-xs text-gray-400 mb-2">Manual Controls</div>
                            <button id="debug-packets-button" class="w-full bg-purple-600/20 hover:bg-purple-600/40 text-purple-300 border border-purple-500/50 px-3 py-2 rounded transition text-xs font-bold">
                                Capture Next Packet to Console
                            </button>
                        </div>
                    </div>
                    <!-- TAB 4: DEBUG -->
                    <div id="tab-device" class="tab-content hidden p-4 space-y-3 absolute inset-0 overflow-y-auto">
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">Hardware Details</h3>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600 space-y-3">
                            <div>
                                <div class="text-xs text-gray-400">Manufacturer</div>
                                <div id="data-manufacturer" class="font-bold text-white">---</div>
                            </div>
                            <div>
                                <div class="text-xs text-gray-400">Model</div>
                                <div id="data-model" class="font-bold text-white">---</div>
                            </div>
                            <div>
                                <div class="text-xs text-gray-400">Serial Number</div>
                                <div id="data-device-serial" class="font-mono text-sm text-gray-300 break-all">---</div>
                            </div>
                        </div>

                        <div class="bg-gray-750 p-3 rounded-lg border border-gray-600 space-y-2">
                            <h4 class="text-xs text-blue-400 font-bold uppercase">Versions</h4>
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Firmware</span>
                                <span id="data-firmware" class="text-white">---</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Hardware</span>
                                <span id="data-hardware" class="text-white">---</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Software</span>
                                <span id="data-software" class="text-white">---</span>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Static Bottom Status -->
                <div class="bg-gray-900 p-3 border-t border-gray-800 text-xs flex justify-between items-center text-gray-500">
                    <span id="data-session-id">Session: --</span>
                    <span id="data-routine-length">Len: --</span>
                </div>
            </div>
        </div>

            <!-- Column 2: Visualizations -->
            <div class="lg:col-span-2 space-y-4">
                <!-- 3D Visualization Card -->
                <div class="card p-4">
                    <h2 class="text-lg font-semibold mb-1">3D Orientation</h2>
                    <div id="three-container" class="bg-gray-800 rounded-lg shadow-md h-96 w-full relative">
                        <div id="three-info" class="absolute top-2 left-2 bg-black/50 text-white text-xs rounded">
                            <button id="three-info-toggle" class="w-full text-left p-2 hover:bg-black/50 rounded font-semibold text-blue-300 flex items-center justify-between">
                                <span>üìä Sensor Data</span>
                                <span id="three-info-toggle-icon" class="icon-container">‚ñº</span>
                            </button>
                            <div id="three-info-content" class="p-2 pt-0">
                            Pitch: <span id="pitch-value">0¬∞</span><br>
                            Roll: <span id="roll-value">0¬∞</span><br>
                            Yaw: <span id="yaw-value">0¬∞</span><br>
                            <span class="text-yellow-300">‚ü≤ Rotation: <span id="rotation-speed">0</span>¬∞/s</span><br>
                            
                            <!-- Circular rotation indicator -->
                            <div class="mt-2 flex items-center gap-2">
                                <div class="relative w-12 h-12">
                                    <svg viewBox="0 0 100 100" class="w-full h-full">
                                        <!-- Background circle -->
                                        <circle cx="50" cy="50" r="45" fill="none" stroke="#374151" stroke-width="2"/>
                                        <!-- Reference marker at top -->
                                        <circle cx="50" cy="10" r="3" fill="#60a5fa"/>
                                        <!-- Rotation indicator line (inside group for rotation) -->
                                        <g id="rotation-indicator">
                                            <line x1="50" y1="50" x2="50" y2="10" 
                                                  stroke="#ef4444" stroke-width="4" stroke-linecap="round"/>
                                        </g>
                                        <!-- Center dot (on top) -->
                                        <circle cx="50" cy="50" r="5" fill="#ef4444"/>
                                    </svg>
                                </div>
                                <div class="text-xs">
                                    <div class="font-semibold text-yellow-300">Brush Spin</div>
                                    <div><span id="yaw-degrees-display">0</span>¬∞</div>
                                </div>
                            </div>
                            
                            <button id="reset-yaw-button" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-2 rounded">
                                Reset Yaw
                            </button>
                            <div class="mt-2 flex gap-1">
                                <button id="rotate-left-button" class="bg-orange-600 hover:bg-orange-700 text-white text-xs font-bold py-1 px-2 rounded">
                                    ‚Üê Rotate Left
                                </button>
                                <button id="rotate-right-button" class="bg-orange-600 hover:bg-orange-700 text-white text-xs font-bold py-1 px-2 rounded">
                                    Rotate Right ‚Üí
                                </button>
                            </div>
                            <button id="calibration-wizard-button" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-2 px-2 rounded">
                                üéØ Calibration Wizard
                            </button>
                            </div>
                        </div>
                        <div id="coordinate-debug" class="absolute bottom-2 left-2 bg-black/70 text-white text-xs rounded font-mono">
                            <button id="coordinate-toggle" class="w-full text-left p-2 hover:bg-black/50 rounded font-semibold text-yellow-300 flex items-center justify-between">
                                <span>üåç Real World (Sensor)</span>
                                <span id="coordinate-toggle-icon">‚ñ∂</span>
                            </button>
                            <div id="coordinate-content" class="p-2 pt-0" style="display: none;">
                                <div>X: <span id="real-x">0.000</span>g</div>
                                <div>Y: <span id="real-y">0.000</span>g (brush length)</div>
                                <div>Z: <span id="real-z">0.000</span>g</div>
                                <div class="font-semibold mt-2 mb-1 text-cyan-300">üéÆ Three.js World:</div>
                                <div>X: <span id="threejs-x">0.000</span> (red axis)</div>
                                <div>Y: <span id="threejs-y">0.000</span> (green axis)</div>
                                <div>Z: <span id="threejs-z">0.000</span> (blue axis, UP)</div>
                                <div class="font-semibold mt-2 mb-1 text-purple-300">üìê Rotation:</div>
                                <div>Pitch: <span id="debug-pitch">0.0</span>¬∞ (X-axis)</div>
                                <div>Roll: <span id="debug-roll">0.0</span>¬∞ (Y-axis)</div>
                                <div>Yaw: <span id="debug-yaw">0.0</span>¬∞ (Z-axis)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sensor Graph -->
                <div class="card p-4">
                    <h2 class="text-lg font-semibold mb-1">Live Sensor Data (Gyro & Accelerometer)</h2>
                    <div class="bg-gray-800 p-4 rounded-lg shadow-md h-96 w-full">
                        <canvas id="sensor-chart-canvas"></canvas>
                    </div>
                </div>
            </div>

        </div> <!-- /Main Content Grid -->

        <!-- Footer / Social Links -->
        <footer class="mt-8 border-t border-gray-700 pt-6">
            <div class="text-center text-xs text-gray-500 mt-4">
                <p>Check out my custom 3D printed enclosures for DIY display modules on Cults3D!</p>
                <p>Like this project? Support the development!</p>
            </div>
        </footer>
        <!-- Calibration Wizard Modal -->
        <div id="calibration-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
            <div class="bg-gray-800 rounded-lg shadow-xl p-6 max-w-2xl w-full mx-4 border-2 border-green-500">
                <h2 class="text-2xl font-bold text-white mb-4">üéØ Gyroscope Calibration Wizard</h2>
                
                <div id="calibration-step-1" class="calibration-step">
                    <p class="text-gray-300 mb-4">This wizard will help you calibrate the gyroscope for accurate rotation tracking.</p>
                    <p class="text-yellow-300 mb-4 font-semibold">Instructions:</p>
                    <ul class="text-gray-300 mb-6 list-disc list-inside space-y-2">
                        <li>Hold the toothbrush <strong>vertically upright</strong> (standing position)</li>
                        <li>When prompted, rotate it <strong>clockwise 360¬∞</strong> around its length</li>
                        <li>Try to rotate at a <strong>steady speed</strong> (about 2-3 seconds per rotation)</li>
                        <li>Click "Stop" when you complete the rotation</li>
                        <li>We'll do 3 test rotations to calculate the perfect scale</li>
                    </ul>
                    <button id="calibration-start-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                        Start Calibration
                    </button>
                    <button id="calibration-cancel-button" class="ml-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg">
                        Cancel
                    </button>
                </div>

                <div id="calibration-step-2" class="calibration-step hidden">
                    <div class="bg-blue-900/50 border-2 border-blue-500 rounded-lg p-6 mb-6">
                        <h3 class="text-xl font-bold text-blue-300 mb-3">Test #<span id="calibration-test-number">1</span> of 3</h3>
                        <p class="text-white text-lg mb-4" id="calibration-instruction">Hold the brush vertically and click "Start Rotating"</p>
                        <div class="text-center">
                            <div class="text-6xl mb-4" id="calibration-icon">ü¶∑</div>
                            <div class="text-3xl font-bold text-yellow-300 mb-2" id="calibration-status">Ready</div>
                        </div>
                    </div>

                    <div class="grid grid-cols-2 gap-4 mb-6">
                        <div class="bg-gray-900/50 rounded-lg p-4">
                            <div class="text-sm text-gray-400">Gyro Z Accumulated</div>
                            <div class="text-2xl font-bold text-white" id="calibration-gyro-accumulated">0</div>
                        </div>
                        <div class="bg-gray-900/50 rounded-lg p-4">
                            <div class="text-sm text-gray-400">Time Elapsed</div>
                            <div class="text-2xl font-bold text-white" id="calibration-time-elapsed">0.0s</div>
                        </div>
                    </div>

                    <div class="flex gap-4">
                        <button id="calibration-rotate-button" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            ‚ñ∂Ô∏è Start Rotating
                        </button>
                        <button id="calibration-stop-button" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg hidden">
                            ‚èπÔ∏è Stop (Rotation Complete)
                        </button>
                        <button id="calibration-cancel-button-2" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg">
                            Cancel
                        </button>
                    </div>
                </div>

                <div id="calibration-step-3" class="calibration-step hidden">
                    <div class="bg-green-900/50 border-2 border-green-500 rounded-lg p-6 mb-6">
                        <h3 class="text-xl font-bold text-green-300 mb-3">‚úÖ Calibration Complete!</h3>
                        <div class="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <div class="text-sm text-gray-400">Test Results:</div>
                                <div id="calibration-results" class="text-white text-sm mt-2 space-y-1"></div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-400">Calculated Scale:</div>
                                <div class="text-3xl font-bold text-green-300 mt-2" id="calibration-calculated-scale">0.000</div>
                                <div class="text-xs text-gray-400 mt-1">Average from all tests</div>
                            </div>
                        </div>
                        <p class="text-gray-300 mb-4">Would you like to apply this calibration?</p>
                    </div>

                    <div class="flex gap-4">
                        <button id="calibration-apply-button" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            ‚úÖ Apply Calibration
                        </button>
                        <button id="calibration-retry-button" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            üîÑ Retry Calibration
                        </button>
                        <button id="calibration-close-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        </div>

    </main> <!-- /Max-width container -->


    <!-- Main Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        /*
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         * SONICARE WEB BLUETOOTH DASHBOARD
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         *
         * CODE ORGANIZATION:
         *
         * 1. BLUETOOTH CONFIGURATION - BLE.SERVICES & BLE.CHARS objects
         * 2. DATA MAPS & LOOKUP TABLES - DATA_MAPS object for value mappings
         * 3. SENSOR & VISUALIZATION CONFIG - CONFIG object for all settings
         * 4. GLOBAL STATE - Application state variables
         * 5. DOM REFERENCES - UI element references
         * 6. UTILITY FUNCTIONS - Helper functions (log, sleep, status updates)
         * 7. 3D VISUALIZATION FUNCTIONS - Three.js related functions
         * 8. BLUETOOTH FUNCTIONS - Connection, data reading, notifications
         * 9. DATA UPDATE FUNCTIONS - UI update handlers
         * 10. SENSOR DATA PROCESSING - Gyro/Accel data handling
         * 11. INITIALIZATION - Event listeners and setup
         *
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         */

        /*
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         * UX & TABS LOGIC
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         */

        // Tab Switching Logic
        document.querySelectorAll('.tab-btn').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active', 'text-blue-400', 'border-b-2', 'border-blue-400');
                    btn.classList.add('text-gray-400');
                });

                // Add active class to clicked button
                button.classList.add('active');

                // Hide all tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                });

                // Show target tab content
                const tabId = button.getAttribute('data-tab');
                document.getElementById(`tab-${tabId}`).classList.remove('hidden');
                document.getElementById(`tab-${tabId}`).classList.add('active');
            });
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BLUETOOTH CONFIGURATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const SONICARE_BASE_UUID = "477ea600-a260-11e4-ae37-0002a5d5";

        const BLE = {
            SERVICES: {
                HANDLE:       `${SONICARE_BASE_UUID}0001`,
                BRUSHING:     `${SONICARE_BASE_UUID}0002`,
                ORIENTATION:  `${SONICARE_BASE_UUID}0005`,
                BRUSH:        `${SONICARE_BASE_UUID}0006`,
                DIAGNOSTIC:   `${SONICARE_BASE_UUID}0007`,
                BATTERY:      0x180f, // Standard Battery Service
                DEVICE_INFO:  0x180a, // Standard Device Information Service
            },
            CHARS: {
                // Battery & Handle
                BATTERY_LEVEL:    0x2a19,
                HANDLE_STATE:     `${SONICARE_BASE_UUID}4010`,
                HANDLE_TIME:      `${SONICARE_BASE_UUID}4050`,
                ROUTINE_ID:       `${SONICARE_BASE_UUID}4022`,
                MOTOR_RUNTIME:    `${SONICARE_BASE_UUID}4040`,
                AVAILABLE_ROUTINES: `${SONICARE_BASE_UUID}4020`,
                // Brushing/Routine Service
                MODE:             `${SONICARE_BASE_UUID}4080`,
                SESSION_STATE:    `${SONICARE_BASE_UUID}4082`,
                SESSION_ID:       `${SONICARE_BASE_UUID}40b1`,
                ACTIVE_TIME:      `${SONICARE_BASE_UUID}4090`,
                STRENGTH:         `${SONICARE_BASE_UUID}40b0`,
                ROUTINE_NUMBER:   `${SONICARE_BASE_UUID}4091`,
                ROUTINE_LENGTH:   `${SONICARE_BASE_UUID}4070`,
                // Orientation/Sensors
                ORIENTATION_CONFIG: `${SONICARE_BASE_UUID}4120`,
                GYRO_DATA:        `${SONICARE_BASE_UUID}4130`,
                ORIENTATION_CTRL: `${SONICARE_BASE_UUID}4140`,
                // Brush Head (Service 6)
                BRUSH_SERIAL:     `${SONICARE_BASE_UUID}4230`,
                BRUSH_USAGE:      `${SONICARE_BASE_UUID}4290`,
                BRUSH_TYPE:       `${SONICARE_BASE_UUID}42a0`,
                NFC_TAG_VERSION:  `${SONICARE_BASE_UUID}4210`,
                FACTORY_MODE:     `${SONICARE_BASE_UUID}4220`,
                LIFETIME_LIMIT:   `${SONICARE_BASE_UUID}4280`,
                BRUSH_HEAD_4270:  `${SONICARE_BASE_UUID}4270`,
                BRUSH_HEAD_4280:  `${SONICARE_BASE_UUID}4280`,
                BRUSH_HEAD_42A2:  `${SONICARE_BASE_UUID}42a2`,
                BRUSH_HEAD_42A4:  `${SONICARE_BASE_UUID}42a4`,
                BRUSH_HEAD_42A6:  `${SONICARE_BASE_UUID}42a6`,
                BRUSH_HEAD_NFC_URL: `${SONICARE_BASE_UUID}42b0`,
                BRUSH_HEAD_42C0:  `${SONICARE_BASE_UUID}42c0`,
                // Diagnostic Service (Service 7)
                ERROR_PERSISTENT: `${SONICARE_BASE_UUID}4310`,
                ERROR_VOLATILE:   `${SONICARE_BASE_UUID}4320`,
                PROXIMITY_VALUE:  `${SONICARE_BASE_UUID}4330`,
                EXTERNAL_FLASH:   `${SONICARE_BASE_UUID}4340`,
                PRESSURE_SENSOR:  `${SONICARE_BASE_UUID}4350`,
                INVALID_CHARGER_COUNT: `${SONICARE_BASE_UUID}4360`,
                DEBUG_INFO:       `${SONICARE_BASE_UUID}4370`,
                // Device Information (Standard BLE)
                MANUFACTURER_NAME: 0x2a29,
                MODEL_NUMBER:      0x2a24,
                SERIAL_NUMBER:     0x2a25,
                HARDWARE_REV:      0x2a27,
                FIRMWARE_REV:      0x2a26,
                SOFTWARE_REV:      0x2a28,
                SYSTEM_ID:         0x2a23,
                IEEE_REGULATORY:   0x2a2a,
                PNP_ID:            0x2a50,
            },
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DATA MAPS & LOOKUP TABLES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const DATA_MAPS = {
            HANDLE_STATE: {
                0: 'Off', 1: 'Standby', 2: 'Run', 3: 'Charge', 4: 'Shutdown',
                6: 'Validate', 7: 'LightsOut',
            },
            BRUSHING_MODE: {
                0x00: 'Clean', 0x01: 'White+', 0x02: 'Gum Health', 0x03: 'Deep Clean+',
                0x78: 'Clean (Alt)', 0xa0: 'White+ (Alt)', 0xb4: 'Deep Clean+ (Alt)', 0xc8: 'Gum Health (Alt)',
            },
            SESSION_STATE: { 0: 'Ready', 1: 'Active', 2: 'Resume' },
            BRUSH_TYPE: { 0: 'None', 1: 'Adaptive Clean', 2: 'Adaptive White', 3: 'Tongue Care', 4: 'Adaptive Gums' },
            STRENGTH: { 0: 'Low', 1: 'Medium', 2: 'High' },
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SENSOR & VISUALIZATION CONFIGURATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //
        // PERFORMANCE OPTIMIZATIONS:
        // ‚Ä¢ DOM element caching - reuse references instead of repeated getElementById()
        // ‚Ä¢ Throttled UI updates - limit updates to 50-200ms intervals
        // ‚Ä¢ Throttled chart updates - 100ms with animation disabled
        // ‚Ä¢ Object reuse - cache Three.js quaternions/vectors to reduce GC pressure
        // ‚Ä¢ Frame limiting - target 60 FPS for animation loop
        // ‚Ä¢ Lazy matrix updates - mark dirty instead of forcing immediate recalculation
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const CONFIG = {
            // Sensor calibration
            ACCEL_SCALE: 1.0 / 4096.0,  // Accelerometer scale factor: converts raw sensor value to 'g' units.
                                        // Source: Sonicare toothbrush IMU datasheet, ¬±4g range = 4096 LSB/g.
                                        // This means each LSB represents 1/4096 g. Used to convert raw readings to physical units.
            GYRO_SCALE: 0.013737,       // Gyroscope scale factor (rad/s per LSB)
                                        // Value determined via Sonicare calibration wizard (2025-04-12) for HX99xx series.
                                        // See device datasheet and calibration logs for details.
            GYRO_DEADBAND: 50,          // Gyroscope deadband threshold (raw sensor units, LSB). Empirically chosen to minimize drift from sensor noise while preserving real motion.
            SMOOTHING: 0.8,             // Rotation speed smoothing (0-1)

            // Connection settings
            MAX_RETRIES: 5,
            TIMEOUT_MS: 20000,          // 20s per connection attempt
            RETRY_BACKOFF_MS: 500,
            MAX_BACKOFF_MS: 2000,

            // Chart & logging
            MAX_CHART_POINTS: 100,
            LOG_INTERVAL_MS: 2000,      // Log sensor data every 2s
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GLOBAL STATE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        let device = null;
        let server = null;
        let sensorChart = null;
        let scene, camera, renderer, controls, toothbrushMesh;
        let lastTimestamp = 0;
        let lastRotationSpeed = 0;
        let brushRotationZ = 0; // Cumulative rotation around brush axis (radians)

        // Calibration wizard state
        let calibrationState = {
            active: false,
            measuring: false,
            testNumber: 0,
            startTime: 0,
            gyroAccumulated: 0,
            measurements: [], // {test, gyroSum, timeElapsed, calculatedScale}
        };
        let lastAccX = 0, lastAccY = -4096, lastAccZ = 0; // Last known accelerometer values (default: upright position)

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DOM REFERENCES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const connectButton = document.getElementById('connect-button');
        const statusMessage = document.getElementById('status-message');
        const statusAlert = document.getElementById('status-alert');
        const connectionProgress = document.getElementById('connection-progress');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const countdownTimer = document.getElementById('countdown-timer');
        const dashboardContent = document.getElementById('dashboard-content');

        const ui = {
            battery: document.getElementById('data-battery'),
            visualBatteryBar: document.getElementById('visual-battery-bar'),
            handleState: document.getElementById('data-handle-state'),
            handleTime: document.getElementById('data-handle-time'),
            routineId: document.getElementById('data-routine-id'),
            motorRuntime: document.getElementById('data-motor-runtime'),
            mode: document.getElementById('data-mode'),
            sessionState: document.getElementById('data-session-state'),
            brushSerial: document.getElementById('data-brush-serial'),
            nfcTagVersion: document.getElementById('data-nfc-tag-version'),
            factoryMode: document.getElementById('data-factory-mode'),
            lifetimeLimit: document.getElementById('data-lifetime-limit'),
            brushUsage: document.getElementById('data-brush-usage'),
            sessionId: document.getElementById('data-session-id'),
            routineNumber: document.getElementById('data-routine-number'),
            routineLength: document.getElementById('data-routine-length'),
            activeTime: document.getElementById('data-active-time'),
            strength: document.getElementById('data-strength'),
            brushType: document.getElementById('data-brush-type'),
            pitch: document.getElementById('pitch-value'),
            roll: document.getElementById('roll-value'),
            yaw: document.getElementById('yaw-value'),
            rotationSpeed: document.getElementById('rotation-speed'),
            manufacturer: document.getElementById('data-manufacturer'),
            model: document.getElementById('data-model'),
            deviceSerial: document.getElementById('data-device-serial'),
            firmware: document.getElementById('data-firmware'),
            hardware: document.getElementById('data-hardware'),
            software: document.getElementById('data-software'),
            sensorConfig: document.getElementById('data-sensor-config'),
            systemId: document.getElementById('data-system-id'),
            ieeeRegulatory: document.getElementById('data-ieee-regulatory'),
            pnpId: document.getElementById('data-pnp-id'),
            brushHead4270: document.getElementById('data-brush-head-4270'),
            brushHead4280: document.getElementById('data-brush-head-4280'),
            brushHead42A2: document.getElementById('data-brush-head-42a2'),
            brushHead42A4: document.getElementById('data-brush-head-42a4'),
            brushHead42A6: document.getElementById('data-brush-head-42a6'),
            brushHeadNfcUrl: document.getElementById('data-brush-head-nfc-url'),
            brushHead42C0: document.getElementById('data-brush-head-42c0'),
            errorPersistent: document.getElementById('data-error-persistent'),
            errorVolatile: document.getElementById('data-error-volatile'),
            proximityValue: document.getElementById('data-proximity-value'),
            pressureSensor: document.getElementById('data-pressure-sensor'),
            invalidChargerCount: document.getElementById('data-invalid-charger-count'),
            debugInfo: document.getElementById('data-debug-info'),
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UTILITY FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        /**
         * Log message to console and update status text
         */
        function log(message) {
            console.log(message);
            statusMessage.textContent = `Status: ${message}`;
        }

        /**
         * Update connection progress bar
         */
        function updateProgress(percent, text) {
            progressBar.style.width = `${percent}%`;
            progressText.textContent = text;
        }

        /**
         * Set status alert to success style
         */
        function setStatusSuccess(message) {
            log(message);
            statusAlert.className = 'bg-green-900/50 border border-green-700 text-green-200 mt-4 p-4 rounded-lg relative';
        }

        /**
         * Set status alert to warning style
         */
        function setStatusWarning(message) {
            log(message);
            statusAlert.className = 'bg-yellow-900/50 border border-yellow-700 text-yellow-200 mt-4 p-4 rounded-lg relative';
        }

        /**
         * Set status alert to error style
         */
        function setStatusError(message) {
            log(message);
            statusAlert.className = 'bg-red-900/50 border border-red-700 text-red-200 mt-4 p-4 rounded-lg relative';
        }

        /**
         * Sleep/delay for specified milliseconds
         */
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Format seconds into human-readable duration
         * @param {number} seconds - Total seconds
         * @returns {string} Formatted string (e.g., "2h 5m" or "45s")
         */
        function formatDuration(seconds) {
            if (seconds < 60) {
                return `${seconds}s`;
            } else if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
            } else {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;
                
                if (minutes === 0 && remainingSeconds === 0) {
                    return `${hours}h`;
                } else if (remainingSeconds === 0) {
                    return `${hours}h ${minutes}m`;
                } else if (minutes === 0) {
                    return `${hours}h ${remainingSeconds}s`;
                } else {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // 3D VISUALIZATION FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        /**
         * Update the cumulative brush rotation angle (yaw)
         * Note: Actual 3D rotation is applied in updateBrushOrientation() to combine with pitch/roll
         * @param {number} angleDelta - Rotation angle in radians (positive = clockwise looking down from brush head)
         * @param {string} [source='manual'] - Source of rotation ('manual', 'gyro') for logging
         */
        function rotateBrushAroundAxis(angleDelta, source = 'manual') {
            if (!toothbrushMesh) {
                console.warn('‚ö†Ô∏è Cannot rotate: toothbrushMesh not initialized');
                return;
            }

            // Update cumulative rotation tracker (this will be applied in updateBrushOrientation)
            brushRotationZ += angleDelta;

            // Calculate degrees and normalize to 0-360 range for display
            let totalDegrees = (brushRotationZ * 180 / Math.PI) % 360;
            if (totalDegrees < 0) totalDegrees += 360; // Handle negative angles
            
            // Throttle UI updates - cache elements and only update every 50ms
            const now = Date.now();
            if (!window.lastUIUpdate || (now - window.lastUIUpdate) > 50) {
                // Update UI - text display
                ui.yaw.textContent = totalDegrees.toFixed(1) + '¬∞';
                
                // Update circular rotation indicator (cache elements)
                if (!window.rotationIndicatorCache) {
                    window.rotationIndicatorCache = document.getElementById('rotation-indicator');
                    window.yawDegreesDisplayCache = document.getElementById('yaw-degrees-display');
                }
                
                if (window.rotationIndicatorCache) {
                    window.rotationIndicatorCache.setAttribute('transform', `rotate(${totalDegrees}, 50, 50)`);
                }
                if (window.yawDegreesDisplayCache) {
                    window.yawDegreesDisplayCache.textContent = totalDegrees.toFixed(0);
                }
                
                window.lastUIUpdate = now;
            }

            // Log rotation (with throttling for gyro updates)
            if (source === 'manual' || !window.lastRotationLog || (Date.now() - window.lastRotationLog) > 2000) {
                window.lastRotationLog = Date.now();
                const degrees = (angleDelta * 180 / Math.PI).toFixed(2);
                const totalDegrees = (brushRotationZ * 180 / Math.PI).toFixed(1);
                console.log(`üîÑ Brush rotation [${source}]: Œî=${degrees}¬∞, total=${totalDegrees}¬∞ (${brushRotationZ.toFixed(3)} rad)`);
            }
        }

        /**
         * Process gyroscope rotation data and update toothbrush Z-axis rotation
         * @param {number} gyroZ - Gyroscope Z-axis raw value
         * @param {number} deltaTime - Time elapsed since last update (seconds)
         */
        function processGyroscopeRotation(gyroZ, deltaTime) {
            // If calibration is active and measuring, accumulate raw gyro values
            if (calibrationState.measuring) {
                calibrationState.gyroAccumulated += Math.abs(gyroZ) * deltaTime;
                
                // Update UI (throttled to every 50ms for calibration display)
                const now = Date.now();
                if (!window.lastCalibrationUpdate || (now - window.lastCalibrationUpdate) > 50) {
                    const timeElapsed = (now - calibrationState.startTime) / 1000;
                    
                    // Cache calibration UI elements
                    if (!window.calibrationUICache) {
                        window.calibrationUICache = {
                            gyroAccum: document.getElementById('calibration-gyro-accumulated'),
                            timeElapsed: document.getElementById('calibration-time-elapsed'),
                        };
                    }
                    
                    if (window.calibrationUICache.gyroAccum) {
                        window.calibrationUICache.gyroAccum.textContent = calibrationState.gyroAccumulated.toFixed(0);
                    }
                    if (window.calibrationUICache.timeElapsed) {
                        window.calibrationUICache.timeElapsed.textContent = timeElapsed.toFixed(1) + 's';
                    }
                    
                    window.lastCalibrationUpdate = now;
                }
                
                return; // Don't apply rotation during calibration
            }

            // Apply deadband to reduce drift from noise
            if (Math.abs(gyroZ) < CONFIG.GYRO_DEADBAND) {
                return;
            }

            // Calculate rotation angle (negate to match visual rotation direction)
            const spinDelta = -gyroZ * CONFIG.GYRO_SCALE * deltaTime;

            // Apply rotation around brush's LOCAL Y-axis
            rotateBrushAroundAxis(spinDelta, 'gyro');

            // Update rotation speed display (exponential smoothing for display only)
            // Throttle to every 100ms
            const now = Date.now();
            if (!window.lastSpeedUpdate || (now - window.lastSpeedUpdate) > 100) {
                const rotationSpeedRaw = Math.abs(gyroZ) * CONFIG.GYRO_SCALE * (180 / Math.PI); // Convert rad/s to deg/s using CONFIG.GYRO_SCALE
                lastRotationSpeed = (CONFIG.SMOOTHING * lastRotationSpeed) + ((1 - CONFIG.SMOOTHING) * rotationSpeedRaw);
                ui.rotationSpeed.textContent = Math.round(lastRotationSpeed);
                window.lastSpeedUpdate = now;
            }
        }

        /**
         * Update 3D model orientation from accelerometer
         * Uses unit vector quaternion approach (proven working in 50743a4a)
         * IMPORTANT: This sets the base orientation (pitch/roll) without affecting spin (yaw)
         *
         * @param {number} accX - Accelerometer X (in g units)
         * @param {number} accY - Accelerometer Y (in g units)
         * @param {number} accZ - Accelerometer Z (in g units)
         */
        function updateBrushOrientation(accX, accY, accZ) {
            if (!toothbrushMesh) return;

            // Calculate gravity magnitude for normalization
            const gravMag = Math.sqrt(accX * accX + accY * accY + accZ * accZ);
            if (gravMag < 0.1) return; // Skip if no significant acceleration

            // Normalize accelerometer values (gravity vector points DOWN)
            const gravX = accX / gravMag;
            const gravY = accY / gravMag;
            const gravZ = accZ / gravMag;

            // Create UP vector (opposite of gravity)
            // When brush stands vertical: accY ‚âà -1g, so UP = -gravity = +Y
            const upX = -gravX;
            const upY = -gravY;
            const upZ = -gravZ;

            // Map accelerometer to target direction in Three.js world space
            // Sensor Y (brush length) should point opposite to gravity (UP in world)
            // Three.js: Y=depth, Z=up
            // When vertical: accY‚âà-1g ‚Üí targetZ=+1 (pointing up along world Z)
            const targetX = upX;   // Maps to world X (left/right)
            const targetY = -upZ;  // Maps to world Y (forward/back) - NOTE: sensor Z ‚Üí world Y - NEGATED to match visual rotation
            const targetZ = upY;   // Maps to world Z (up) - NOTE: sensor Y ‚Üí world Z
            
            // Reuse quaternion objects to reduce garbage collection
            if (!window.quaternionCache) {
                window.quaternionCache = {
                    brushLocalY: new THREE.Vector3(0, 1, 0),
                    targetDirection: new THREE.Vector3(),
                    spinAxis: new THREE.Vector3(0, 1, 0),
                    qOrientation: new THREE.Quaternion(),
                    qSpin: new THREE.Quaternion(),
                    qFinal: new THREE.Quaternion(),
                };
            }
            
            const cache = window.quaternionCache;
            
            // Update target direction
            cache.targetDirection.set(targetX, targetY, targetZ);
            
            // Create quaternion to align cylinder's Y-axis with target direction
            cache.qOrientation.setFromUnitVectors(cache.brushLocalY, cache.targetDirection);

            // Combine orientation quaternion with spin rotation
            cache.qSpin.setFromAxisAngle(cache.spinAxis, brushRotationZ);

            // Apply orientation first, then spin around the oriented Y-axis
            cache.qFinal.multiplyQuaternions(cache.qOrientation, cache.qSpin);
            
            // Apply combined rotation
            toothbrushMesh.quaternion.copy(cache.qFinal);
            
            // Matrix updates are automatically handled by Three.js renderer
            // No need to force update every frame - only mark as needing update
            toothbrushMesh.matrixWorldNeedsUpdate = true;

            // Throttle pitch/roll UI updates (already have orientation data)
            const now = Date.now();
            if (!window.lastPitchRollUpdate || (now - window.lastPitchRollUpdate) > 100) {
                const pitch = Math.atan2(upX, upY);
                const roll = Math.atan2(upZ, upY);
                ui.pitch.textContent = (pitch * 180 / Math.PI).toFixed(1) + '¬∞';
                ui.roll.textContent = (roll * 180 / Math.PI).toFixed(1) + '¬∞';
                window.lastPitchRollUpdate = now;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION & EVENT LISTENERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Connect button
        connectButton.addEventListener('click', connectDevice);

        // Reset yaw (Z-axis rotation) button
        document.getElementById('reset-yaw-button').addEventListener('click', () => {
            brushRotationZ = 0;
            // Apply the reset to the 3D model
            updateBrushOrientation(lastAccX * CONFIG.ACCEL_SCALE, lastAccY * CONFIG.ACCEL_SCALE, lastAccZ * CONFIG.ACCEL_SCALE);
            log('Yaw reset to 0¬∞');
        });

        // Manual rotation test buttons (for debugging)
        document.getElementById('rotate-left-button').addEventListener('click', () => {
            rotateBrushAroundAxis(-Math.PI / 6, 'manual-left'); // -30 degrees (counter-clockwise)
            // Apply rotation to 3D model using last known accelerometer values
            updateBrushOrientation(lastAccX * CONFIG.ACCEL_SCALE, lastAccY * CONFIG.ACCEL_SCALE, lastAccZ * CONFIG.ACCEL_SCALE);
            console.log('üîÑ Manual rotate left: Applied rotation to 3D model');
        });

        document.getElementById('rotate-right-button').addEventListener('click', () => {
            rotateBrushAroundAxis(Math.PI / 6, 'manual-right'); // +30 degrees (clockwise)
            // Apply rotation to 3D model using last known accelerometer values
            updateBrushOrientation(lastAccX * CONFIG.ACCEL_SCALE, lastAccY * CONFIG.ACCEL_SCALE, lastAccZ * CONFIG.ACCEL_SCALE);
            console.log('üîÑ Manual rotate right: Applied rotation to 3D model');
        });

        // Debug packet dump button
        document.getElementById('debug-packets-button').addEventListener('click', () => {
            window.debugNextPacket = true;
            log('üîç Debug mode enabled - will dump next packet in detail');
        });

        // Three-info toggle button
        document.getElementById('three-info-toggle').addEventListener('click', () => {
            const content = document.getElementById('three-info-content');
            const icon = document.getElementById('three-info-toggle-icon');
            const isCollapsed = content.classList.contains('collapsed');
            
            if (isCollapsed) {
                content.classList.remove('collapsed');
                icon.textContent = '‚ñº';
            } else {
                content.classList.add('collapsed');
                icon.textContent = '‚ñ∂';
            }
        });

        // Coordinate debug toggle button
        document.getElementById('coordinate-toggle').addEventListener('click', () => {
            const content = document.getElementById('coordinate-content');
            const icon = document.getElementById('coordinate-toggle-icon');
            const isCollapsed = content.classList.contains('collapsed');
            
            if (isCollapsed) {
                content.classList.remove('collapsed');
                icon.textContent = '‚ñº';
            } else {
                content.classList.add('collapsed');
                icon.textContent = '‚ñ∂';
            }
        });

        // Set initial icon states based on viewport width (mobile collapsed by default)
        window.addEventListener('DOMContentLoaded', () => {
            const threeInfoContent = document.getElementById('three-info-content');
            const threeInfoIcon = document.getElementById('three-info-toggle-icon');
            const coordinateContent = document.getElementById('coordinate-content');
            const coordinateIcon = document.getElementById('coordinate-toggle-icon');
            
            // On mobile (<=768px), add collapsed class and set icon
            if (window.innerWidth <= 768) {
                threeInfoContent.classList.add('collapsed');
                coordinateContent.classList.add('collapsed');
                threeInfoIcon.textContent = '‚ñ∂';
                coordinateIcon.textContent = '‚ñ∂';
            } else {
                threeInfoIcon.textContent = '‚ñº';
                coordinateIcon.textContent = '‚ñº';
            }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CALIBRATION WIZARD
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        document.getElementById('calibration-wizard-button').addEventListener('click', openCalibrationWizard);

        function openCalibrationWizard() {
            document.getElementById('calibration-modal').classList.remove('hidden');
            document.getElementById('calibration-step-1').classList.remove('hidden');
            document.getElementById('calibration-step-2').classList.add('hidden');
            document.getElementById('calibration-step-3').classList.add('hidden');
            
            calibrationState = {
                active: true,
                measuring: false,
                testNumber: 0,
                startTime: 0,
                gyroAccumulated: 0,
                measurements: [],
            };
        }

        function closeCalibrationWizard() {
            document.getElementById('calibration-modal').classList.add('hidden');
            calibrationState.active = false;
            calibrationState.measuring = false;
        }

        document.getElementById('calibration-start-button').addEventListener('click', () => {
            document.getElementById('calibration-step-1').classList.add('hidden');
            document.getElementById('calibration-step-2').classList.remove('hidden');
            startCalibrationTest();
        });

        document.getElementById('calibration-cancel-button').addEventListener('click', closeCalibrationWizard);
        document.getElementById('calibration-cancel-button-2').addEventListener('click', closeCalibrationWizard);

        document.getElementById('calibration-rotate-button').addEventListener('click', () => {
            calibrationState.measuring = true;
            calibrationState.startTime = Date.now();
            calibrationState.gyroAccumulated = 0;
            
            document.getElementById('calibration-rotate-button').classList.add('hidden');
            document.getElementById('calibration-stop-button').classList.remove('hidden');
            document.getElementById('calibration-status').textContent = 'Rotating...';
            document.getElementById('calibration-icon').textContent = 'üîÑ';
            document.getElementById('calibration-instruction').textContent = 'Rotate the brush 360¬∞ clockwise, then click "Stop"';
            
            log('üéØ Calibration test #' + (calibrationState.testNumber + 1) + ' started');
        });

        document.getElementById('calibration-stop-button').addEventListener('click', () => {
            calibrationState.measuring = false;
            const timeElapsed = (Date.now() - calibrationState.startTime) / 1000;
            
            // Calculate scale: 360¬∞ (2œÄ radians) divided by accumulated gyro readings
            const targetRotation = 2 * Math.PI; // 360 degrees in radians
            const calculatedScale = targetRotation / calibrationState.gyroAccumulated;
            
            calibrationState.measurements.push({
                test: calibrationState.testNumber + 1,
                gyroSum: calibrationState.gyroAccumulated,
                timeElapsed: timeElapsed,
                calculatedScale: calculatedScale,
            });
            
            log(`‚úÖ Test #${calibrationState.testNumber + 1}: gyroSum=${calibrationState.gyroAccumulated.toFixed(0)}, time=${timeElapsed.toFixed(1)}s, scale=${calculatedScale.toFixed(6)}`);
            
            calibrationState.testNumber++;
            
            if (calibrationState.testNumber >= 3) {
                // All tests complete, show results
                showCalibrationResults();
            } else {
                // Next test
                startCalibrationTest();
            }
        });

        function startCalibrationTest() {
            document.getElementById('calibration-test-number').textContent = calibrationState.testNumber + 1;
            document.getElementById('calibration-rotate-button').classList.remove('hidden');
            document.getElementById('calibration-stop-button').classList.add('hidden');
            document.getElementById('calibration-status').textContent = 'Ready';
            document.getElementById('calibration-icon').textContent = 'ü¶∑';
            document.getElementById('calibration-instruction').textContent = 'Hold the brush vertically and click "Start Rotating"';
            document.getElementById('calibration-gyro-accumulated').textContent = '0';
            document.getElementById('calibration-time-elapsed').textContent = '0.0s';
        }

        function showCalibrationResults() {
            document.getElementById('calibration-step-2').classList.add('hidden');
            document.getElementById('calibration-step-3').classList.remove('hidden');
            
            // Calculate average scale
            const avgScale = calibrationState.measurements.reduce((sum, m) => sum + m.calculatedScale, 0) / calibrationState.measurements.length;
            
            // Display results
            const resultsDiv = document.getElementById('calibration-results');
            resultsDiv.innerHTML = calibrationState.measurements.map(m => 
                `Test ${m.test}: Scale = ${m.calculatedScale.toFixed(6)} (gyro: ${m.gyroSum.toFixed(0)})`
            ).join('<br>');
            
            document.getElementById('calibration-calculated-scale').textContent = avgScale.toFixed(6);
            
            calibrationState.calculatedScale = avgScale;
            log(`üìä Calibration complete: Average GYRO_SCALE = ${avgScale.toFixed(6)}`);
        }

        document.getElementById('calibration-apply-button').addEventListener('click', () => {
            CONFIG.GYRO_SCALE = calibrationState.calculatedScale;
            log(`‚úÖ Applied new GYRO_SCALE: ${CONFIG.GYRO_SCALE.toFixed(6)}`);
            alert(`Calibration applied! New GYRO_SCALE: ${CONFIG.GYRO_SCALE.toFixed(6)}`);
            closeCalibrationWizard();
        });

        document.getElementById('calibration-retry-button').addEventListener('click', () => {
            document.getElementById('calibration-step-3').classList.add('hidden');
            document.getElementById('calibration-step-1').classList.remove('hidden');
            calibrationState.testNumber = 0;
            calibrationState.measurements = [];
        });

        document.getElementById('calibration-close-button').addEventListener('click', closeCalibrationWizard);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // THREE.JS 3D VISUALIZATION SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Optimize animation loop - skip frames if needed
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            // Throttle to target FPS
            if (currentTime - lastFrameTime < frameInterval) {
                return; // Skip this frame
            }
            lastFrameTime = currentTime;
            
            controls.update();
            renderer.render(scene, camera);
        }

        /**
         * Create the toothbrush 3D model with handle, brush head, and visual markers
         * @returns {THREE.Group} The toothbrush mesh group
         */
        function createToothbrush() {
            const toothbrushModel = new THREE.Group();
            toothbrushModel.castShadow = true;
            
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.1
            });
            
            const buttonMaterial = new THREE.MeshStandardMaterial({
                color: 0x4299e1, // A "Sonicare" blue
                roughness: 0.5,
            });

            const bristleMaterial = new THREE.MeshStandardMaterial({
                color: 0xa0deff, // Light blue bristles
                roughness: 0.6,
            });

            // Calculate total height to find midpoint
            const handleLength = 10;
            const neckLength = 2;
            const headLength = 1.8;
            const bristleHeight = 0.4;
            const totalHeight = handleLength + neckLength + headLength / 2 + bristleHeight;
            const midpoint = totalHeight / 2;

            // 1. Main Handle (centered around midpoint)
            const handleRadiusTop = 0.6;
            const handleRadiusBottom = 0.7;
            const handleGeometry = new THREE.CylinderGeometry(handleRadiusBottom, handleRadiusTop, handleLength, 32);
            const handle = new THREE.Mesh(handleGeometry, bodyMaterial);
            handle.position.y = handleLength / 2 - midpoint; // Offset by midpoint
            handle.castShadow = true;
            toothbrushModel.add(handle);

            // 2. Button
            const buttonGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 16);
            const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
            button.position.set(0, 7 - midpoint, 0.65); // Offset by midpoint
            button.rotation.x = Math.PI / 2;
            toothbrushModel.add(button);

            // 3. Neck
            const neckGeometry = new THREE.CylinderGeometry(0.3, 0.3, neckLength, 32);
            const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
            neck.position.y = 11 - midpoint; // Offset by midpoint
            neck.castShadow = true;
            toothbrushModel.add(neck);

            // 4. Head
            const headGeometry = new THREE.BoxGeometry(0.8, headLength, 0.5);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 12.8 - midpoint; // Offset by midpoint
            head.castShadow = true;
            toothbrushModel.add(head);

            // 5. Bristles
            const bristleGeometry = new THREE.BoxGeometry(0.6, 1.4, bristleHeight);
            const bristles = new THREE.Mesh(bristleGeometry, bristleMaterial);
            bristles.position.y = 12.8 - midpoint; // Offset by midpoint
            bristles.position.z = 0.4;
            bristles.castShadow = true;
            toothbrushModel.add(bristles);

            // Add a marker line on the back to help see rotation
            const lineGeometry = new THREE.BoxGeometry(0.05, handleLength, 0.05);
            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
            const backMarker = new THREE.Mesh(lineGeometry, lineMaterial);
            backMarker.position.set(0, handleLength / 2 - midpoint, -handleRadiusBottom); // Offset by midpoint
            toothbrushModel.add(backMarker);

            toothbrushModel.rotation.x = Math.PI / 2;
            toothbrushModel.scale.set(0.4, 0.4, 0.4);

            return toothbrushModel;
        }

        function initThreeJS() {
            const container = document.getElementById('three-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d3748); // bg-gray-800
            
            // Camera - positioned to look down at desk from viewer's perspective
            // Simulates looking at toothbrush standing on desk in front of you
            const sizes = {
              width: container.offsetWidth,
              height: container.offsetHeight
            };
            camera = new THREE.PerspectiveCamera(50, sizes.width / sizes.height, 0.1, 300);
            // Position: adjusted for optimal viewing angle
            camera.position.set(3.87, -7.54, 5.30);
            camera.lookAt(0, 0, 1.5);  // Look at brush center
            // Up vector: Z points up (normal orientation)
            camera.up.set(0, 0, 1);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Create and add toothbrush model
            toothbrushMesh = createToothbrush();
            scene.add(toothbrushMesh);

            // Axes Helper
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Add X, Y, Z labels using sprites
            const createTextLabel = (text, color, position) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 128;

                context.font = 'Bold 80px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 64, 64);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.5, 0.5, 1);
                sprite.position.copy(position);
                return sprite;
            };

            // Add labels at the end of each axis showing Three.js axis names
            // Three.js coordinate system:
            // X-axis (red) = horizontal right
            scene.add(createTextLabel('X', '#ff0000', new THREE.Vector3(3.5, 0, 0)));
            // Y-axis (green) = horizontal forward (depth)
            scene.add(createTextLabel('Y', '#00ff00', new THREE.Vector3(0, 3.5, 0)));
            // Z-axis (blue) = vertical UP
            scene.add(createTextLabel('Z', '#0000ff', new THREE.Vector3(0, 0, 3.5)));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Controls - Enabled for camera positioning
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enabled = true; // Enable mouse controls (zoom, rotate, pan)

            // Handle resizing
            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });

            // Start animation loop
            animate();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHART.JS SENSOR GRAPH SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function initChartJS() {
            const ctx = document.getElementById('sensor-chart-canvas').getContext('2d');
            sensorChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Gyro X', borderColor: 'rgba(255, 99, 132, 1)', data: [], fill: false, tension: 0.1 },
                        { label: 'Gyro Y', borderColor: 'rgba(54, 162, 235, 1)', data: [], fill: false, tension: 0.1 },
                        { label: 'Gyro Z', borderColor: 'rgba(255, 206, 86, 1)', data: [], fill: false, tension: 0.1 },
                        { label: 'Accel X', borderColor: 'rgba(75, 192, 192, 0.5)', data: [], fill: false, tension: 0.1, borderDash: [5, 5] },
                        { label: 'Accel Y', borderColor: 'rgba(153, 102, 255, 0.5)', data: [], fill: false, tension: 0.1, borderDash: [5, 5] },
                        { label: 'Accel Z', borderColor: 'rgba(255, 159, 64, 0.5)', data: [], fill: false, tension: 0.1, borderDash: [5, 5] },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { ticks: { display: false }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' } }
                    },
                    plugins: { legend: { labels: { color: 'white' } } },
                    animation: false
                }
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZE VISUALIZATION & CHART
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Initialize 3D visualization
        initThreeJS();

        // Initialize chart
        initChartJS();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BLUETOOTH CONNECTION FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        async function connectDevice() {
            updateProgress(0, 'Starting connection...');
            connectionProgress.classList.remove('hidden');
            connectButton.disabled = true;

            try {
                // Step 1: Request device (requires user gesture - can only happen once)
                log('Requesting Bluetooth Device...');
                updateProgress(10, 'üì± Opening Bluetooth selector... SELECT YOUR DEVICE!');

                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [BLE.SERVICES.HANDLE] }],
                    optionalServices: [
                        BLE.SERVICES.HANDLE, BLE.SERVICES.BRUSHING, BLE.SERVICES.ORIENTATION,
                        BLE.SERVICES.BRUSH, BLE.SERVICES.BATTERY, BLE.SERVICES.DEVICE_INFO
                    ]
                });

                updateProgress(30, '‚úÖ Device selected! Connecting to GATT...');
                log('Device selected. Connecting to GATT Server...');

                device.addEventListener('gattserverdisconnected', onDisconnected);

                // Step 2: Connect to GATT with improved retry logic
                const MAX_RETRIES = CONFIG.MAX_RETRIES;
                const TIMEOUT_MS = CONFIG.TIMEOUT_MS;
                let connected = false;

                for (let attempt = 0; attempt < MAX_RETRIES && !connected; attempt++) {
                    try {
                        if (attempt > 0) {
                            // Exponential backoff: 500ms, 1000ms, 1500ms, 2000ms
                            const waitTime = Math.min(CONFIG.RETRY_BACKOFF_MS * attempt, CONFIG.MAX_BACKOFF_MS);
                            log(`‚è≥ Waiting ${waitTime}ms before retry ${attempt + 1}/${MAX_RETRIES}...`);
                            updateProgress(30 + (attempt * 10), `‚è≥ Retry ${attempt}/${MAX_RETRIES - 1} in ${waitTime}ms...`);
                            await sleep(waitTime);
                        }

                        const attemptMsg = attempt === 0
                            ? 'üîó Connecting... (Keep toothbrush awake!)'
                            : `üîó Retry ${attempt}/${MAX_RETRIES - 1}... (KEEP TOOTHBRUSH MOVING!)`;

                        updateProgress(30 + (attempt * 12), attemptMsg);
                        log(`Connection attempt ${attempt + 1}/${MAX_RETRIES}...`);

                        // Try to connect with timeout AND countdown
                        server = await connectWithTimeout(device, TIMEOUT_MS, attempt + 1, MAX_RETRIES);

                        connected = true;
                        countdownTimer.textContent = ''; // Clear countdown
                        updateProgress(70, '‚úÖ Connected! Keeping device awake...');
                        log('‚úÖ Connected! Fetching services...');

                        // Add a delay to ensure connection is stable
                        // The toothbrush goes to sleep very quickly if idle
                        await sleep(1000);

                        // Verify still connected after delay
                        if (!server || !server.connected) {
                            throw new Error('Device went to sleep during connection. Try again with toothbrush ON CHARGER.');
                        }

                    } catch (connectError) {
                        countdownTimer.textContent = ''; // Clear countdown on error

                        if (attempt < MAX_RETRIES - 1) {
                            log(`‚ùå Connection failed: ${connectError.message}. Retrying...`);
                            setStatusWarning(`‚ö†Ô∏è Retry ${attempt + 1}/${MAX_RETRIES}... KEEP TOOTHBRUSH AWAKE! (on charger = best)`);
                        } else {
                            throw new Error(`Failed after ${MAX_RETRIES} attempts: ${connectError.message}`);
                        }
                    }
                }

                // Step 3: Read static data
                updateProgress(75, 'üìñ Reading device data...');
                try {
                    await readStaticData();
                } catch (readError) {
                    log(`Error reading static data: ${readError.message}`);
                    // Don't fail entirely - continue to notifications
                }

                updateProgress(85, 'üìä Data loaded! Subscribing to live updates...');

                // Step 4: Subscribe to notifications
                try {
                    await subscribeToNotifications();
                } catch (subError) {
                    throw new Error(`Error subscribing to notifications: ${subError.message}`);
                }

                updateProgress(100, 'üéâ Fully connected!');

                setTimeout(() => {
                    connectionProgress.classList.add('hidden');
                    setStatusSuccess('‚úÖ Connected successfully! Data is now streaming.');
                    
                    // Remove blur effect from dashboard content
                    dashboardContent.classList.add('connected');
                }, 2000);

                connectButton.disabled = false;
                connectButton.textContent = "Disconnect";
                connectButton.onclick = disconnectDevice;

            } catch(error) {
                connectionProgress.classList.add('hidden');
                connectButton.disabled = false;
                countdownTimer.textContent = '';
                
                // Re-apply blur effect to dashboard content
                dashboardContent.classList.remove('connected');

                if (error.name === 'NotFoundError') {
                    log('‚ùå No device found. Make sure toothbrush is awake and nearby.');
                    setStatusError('‚ùå No device found. Is Bluetooth enabled? Is toothbrush nearby?');
                } else if (error.message.includes('User cancelled')) {
                    log('‚ÑπÔ∏è User cancelled device selection.');
                    setStatusWarning('‚ÑπÔ∏è Connection cancelled by user. Click Connect to try again.');
                } else if (error.message.includes('Failed after')) {
                    log(`‚ùå ${error.message}`);
                    setStatusError('‚ùå All retries failed! TIP: Place toothbrush ON CHARGER and try again.');
                } else if (error.message.includes('went to sleep') || error.message.includes('disconnected before')) {
                    log(`‚ùå ${error.message}`);
                    setStatusError('‚ùå Toothbrush went to sleep! TIP: Keep it ON CHARGER during connection.');
                } else {
                    log(`‚ùå Error: ${error.message}`);
                    setStatusError(`‚ùå Error: ${error.message}`);
                }
            }
        }

        // New helper function: Connect with timeout AND visual countdown
        async function connectWithTimeout(device, timeoutMs, attemptNum, maxAttempts) {
            let countdownInterval;
            const startTime = Date.now();

            // Start countdown timer
            countdownInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, Math.ceil((timeoutMs - elapsed) / 1000));
                countdownTimer.textContent = `‚è±Ô∏è ${remaining}s`;

                if (remaining === 0) {
                    clearInterval(countdownInterval);
                }
            }, 100);

            try {
                const result = await Promise.race([
                    device.gatt.connect(),
                    new Promise((_, reject) => {
                        setTimeout(() => {
                            reject(new Error(`Connection timeout (${timeoutMs/1000}s)`));
                        }, timeoutMs);
                    })
                ]);

                clearInterval(countdownInterval);
                return result;
            } catch (error) {
                clearInterval(countdownInterval);
                throw error;
            }
        }

        async function disconnectDevice() {
            if (!device) return;
            log('Disconnecting...');
            countdownTimer.textContent = '';
            if (device.gatt.connected) {
                await device.gatt.disconnect();
            } else {
                log('Already disconnected.');
            }
            setStatusWarning('‚ÑπÔ∏è Disconnected. Click Connect to reconnect.');
        }

        function onDisconnected() {
            log('Device Disconnected.');
            countdownTimer.textContent = '';
            connectButton.textContent = "Connect to Toothbrush";
            connectButton.onclick = connectDevice;
            connectButton.disabled = false;
            setStatusWarning('‚ö†Ô∏è Device disconnected. Toothbrush may have gone to sleep.');
            
            // Re-apply blur effect to dashboard content
            dashboardContent.classList.remove('connected');
        }

        async function readStaticData() {
            log('Reading static data...');

            // Check if device is still connected
            if (!server || !server.connected) {
                throw new Error('Device disconnected before static data could be read');
            }

            try {
                // Get Battery
                const batteryService = await server.getPrimaryService(BLE.SERVICES.BATTERY);
                const batteryChar = await batteryService.getCharacteristic(BLE.CHARS.BATTERY_LEVEL);
                const batteryValue = await batteryChar.readValue();
                const batteryLevel = batteryValue.getUint8(0);
                ui.battery.textContent = `${batteryLevel} %`;
                
                // Update visual battery bar
                if (ui.visualBatteryBar) {
                    ui.visualBatteryBar.style.width = `${batteryLevel}%`;
                    // Remove all color classes
                    ui.visualBatteryBar.classList.remove('high', 'medium', 'low');
                    // Add appropriate color class based on battery level
                    if (batteryLevel > 60) {
                        ui.visualBatteryBar.classList.add('high');
                    } else if (batteryLevel > 30) {
                        ui.visualBatteryBar.classList.add('medium');
                    } else {
                        ui.visualBatteryBar.classList.add('low');
                    }
                }
                
                // Get Handle Service
                const handleService = await server.getPrimaryService(BLE.SERVICES.HANDLE);

                // Get Handle State
                const handleStateChar = await handleService.getCharacteristic(BLE.CHARS.HANDLE_STATE);
                const handleStateValue = await handleStateChar.readValue();
                updateHandleState(handleStateValue);

                // Get Handle Time
                try {
                    const handleTimeChar = await handleService.getCharacteristic(BLE.CHARS.HANDLE_TIME);
                    const handleTimeValue = await handleTimeChar.readValue();
                    if (handleTimeValue.byteLength >= 4) {
                        const timestamp = handleTimeValue.getUint32(0, true);
                        const date = new Date(timestamp * 1000);
                        ui.handleTime.textContent = date.toLocaleString();
                    } else {
                        ui.handleTime.textContent = 'Invalid data';
                    }
                } catch (e) {
                    log(`Handle Time read error: ${e.message}`);
                    ui.handleTime.textContent = 'N/A';
                }

                // Get Routine ID
                try {
                    const routineIdChar = await handleService.getCharacteristic(BLE.CHARS.ROUTINE_ID);
                    const routineIdValue = await routineIdChar.readValue();
                    if (routineIdValue.byteLength >= 1) {
                        ui.routineId.textContent = routineIdValue.getUint8(0);
                    } else {
                        ui.routineId.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Routine ID read error: ${e.message}`);
                    ui.routineId.textContent = 'N/A';
                }

                // Get Motor Runtime
                try {
                    const motorRuntimeChar = await handleService.getCharacteristic(BLE.CHARS.MOTOR_RUNTIME);
                    const motorRuntimeValue = await motorRuntimeChar.readValue();
                    if (motorRuntimeValue.byteLength >= 4) {
                        const seconds = motorRuntimeValue.getUint32(0, true);
                        ui.motorRuntime.textContent = formatDuration(seconds);
                    } else if (motorRuntimeValue.byteLength >= 2) {
                        const seconds = motorRuntimeValue.getUint16(0, true);
                        ui.motorRuntime.textContent = formatDuration(seconds);
                    } else {
                        ui.motorRuntime.textContent = 'Invalid data';
                    }
                } catch (e) {
                    log(`Motor Runtime read error: ${e.message}`);
                    ui.motorRuntime.textContent = 'N/A';
                }
                
                // Get Brushing Service
                const brushingService = await server.getPrimaryService(BLE.SERVICES.BRUSHING);

                // Get Mode
                const modeChar = await brushingService.getCharacteristic(BLE.CHARS.MODE);
                const modeValue = await modeChar.readValue();
                updateMode(modeValue);

                // Get Brush Service
                const brushService = await server.getPrimaryService(BLE.SERVICES.BRUSH);
                const textDecoder = new TextDecoder('utf-8');

                // Get Brush Serial (binary data - display as hex)
                try {
                    const brushSerialChar = await brushService.getCharacteristic(BLE.CHARS.BRUSH_SERIAL);
                    const brushSerialValue = await brushSerialChar.readValue();

                    if (brushSerialValue.byteLength > 0) {
                        // Display as hex bytes (e.g., "3B 42 8F A1")
                        const hexArray = Array.from(new Uint8Array(brushSerialValue.buffer))
                            .map(b => b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushSerial.textContent = hexArray.join(' ');
                    } else {
                        ui.brushSerial.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Serial read error: ${e.message}`);
                    ui.brushSerial.textContent = 'Error reading';
                }

                // Get Brush Usage (with error handling)
                try {
                    const brushUsageChar = await brushService.getCharacteristic(BLE.CHARS.BRUSH_USAGE);
                    const brushUsageValue = await brushUsageChar.readValue();
                    if (brushUsageValue.byteLength >= 4) {
                        // 4-byte unsigned int, little-endian
                        const seconds = brushUsageValue.getUint32(0, true);
                        ui.brushUsage.textContent = formatDuration(seconds);
                    } else if (brushUsageValue.byteLength >= 2) {
                        // Fallback: try 2-byte value
                        const seconds = brushUsageValue.getUint16(0, true);
                        ui.brushUsage.textContent = formatDuration(seconds);
                    } else {
                        ui.brushUsage.textContent = 'Invalid data length';
                        log(`Brush Usage: unexpected length ${brushUsageValue.byteLength}`);
                    }
                } catch (e) {
                    log(`Brush Usage read error: ${e.message}`);
                    ui.brushUsage.textContent = 'Error reading';
                }

                // Get Brush Type (with error handling)
                try {
                    const brushTypeChar = await brushService.getCharacteristic(BLE.CHARS.BRUSH_TYPE);
                    const brushTypeValue = await brushTypeChar.readValue();
                    if (brushTypeValue.byteLength >= 1) {
                        const brushType = brushTypeValue.getUint8(0);
                        ui.brushType.textContent = DATA_MAPS.BRUSH_TYPE[brushType] || `Unknown (${brushType})`;
                    } else {
                        ui.brushType.textContent = 'No data';
                        log(`Brush Type: empty response`);
                    }
                } catch (e) {
                    log(`Brush Type read error: ${e.message}`);
                    ui.brushType.textContent = 'Error reading';
                }

                // Get NFC Tag Version
                try {
                    const nfcTagVersionChar = await brushService.getCharacteristic(BLE.CHARS.NFC_TAG_VERSION);
                    const nfcTagVersionValue = await nfcTagVersionChar.readValue();
                    if (nfcTagVersionValue.byteLength > 0) {
                        const hexArray = Array.from(new Uint8Array(nfcTagVersionValue.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.nfcTagVersion.textContent = hexArray.join(', ');
                    } else {
                        ui.nfcTagVersion.textContent = 'No data';
                    }
                } catch (e) {
                    log(`NFC Tag Version read error: ${e.message}`);
                    ui.nfcTagVersion.textContent = 'N/A';
                }

                // Get Factory Mode
                try {
                    const factoryModeChar = await brushService.getCharacteristic(BLE.CHARS.FACTORY_MODE);
                    const factoryModeValue = await factoryModeChar.readValue();
                    if (factoryModeValue.byteLength >= 3) {
                        // 17-bit integer (3 bytes, use first 17 bits)
                        const value = factoryModeValue.getUint8(0) | 
                                      (factoryModeValue.getUint8(1) << 8) | 
                                      ((factoryModeValue.getUint8(2) & 0x01) << 16);
                        ui.factoryMode.textContent = `0x${value.toString(16).toUpperCase()} (${value})`;
                    } else if (factoryModeValue.byteLength >= 1) {
                        ui.factoryMode.textContent = `0x${factoryModeValue.getUint8(0).toString(16).toUpperCase()}`;
                    } else {
                        ui.factoryMode.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Factory Mode read error: ${e.message}`);
                    ui.factoryMode.textContent = 'N/A';
                }

                // Get Lifetime Limit
                try {
                    const lifetimeLimitChar = await brushService.getCharacteristic(BLE.CHARS.LIFETIME_LIMIT);
                    const lifetimeLimitValue = await lifetimeLimitChar.readValue();
                    if (lifetimeLimitValue.byteLength >= 3) {
                        // 18-bit integer (3 bytes)
                        const seconds = lifetimeLimitValue.getUint8(0) | 
                                        (lifetimeLimitValue.getUint8(1) << 8) | 
                                        ((lifetimeLimitValue.getUint8(2) & 0x03) << 16);
                        ui.lifetimeLimit.textContent = formatDuration(seconds);
                    } else if (lifetimeLimitValue.byteLength >= 2) {
                        const seconds = lifetimeLimitValue.getUint16(0, true);
                        ui.lifetimeLimit.textContent = formatDuration(seconds);
                    } else {
                        ui.lifetimeLimit.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Lifetime Limit read error: ${e.message}`);
                    ui.lifetimeLimit.textContent = 'N/A';
                }

                // Get Brush Head 4270
                try {
                    const char4270 = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_4270);
                    const value4270 = await char4270.readValue();
                    if (value4270.byteLength > 0) {
                        const textValue = textDecoder.decode(value4270).trim();
                        const hexArray = Array.from(new Uint8Array(value4270.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushHead4270.textContent = textValue.length > 0 ? `"${textValue}" (${hexArray.join(', ')})` : hexArray.join(', ');
                        log(`Brush Head 4270: "${textValue}" = ${hexArray.join(', ')}`);
                    } else {
                        ui.brushHead4270.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head 4270 read error: ${e.message}`);
                    ui.brushHead4270.textContent = 'N/A';
                }

                // Get Brush Head 4280
                try {
                    const char4280 = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_4280);
                    const value4280 = await char4280.readValue();
                    if (value4280.byteLength > 0) {
                        const textValue = textDecoder.decode(value4280).trim();
                        const hexArray = Array.from(new Uint8Array(value4280.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushHead4280.textContent = textValue.length > 0 ? `"${textValue}" (${hexArray.join(', ')})` : hexArray.join(', ');
                        log(`Brush Head 4280: "${textValue}" = ${hexArray.join(', ')}`);
                    } else {
                        ui.brushHead4280.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head 4280 read error: ${e.message}`);
                    ui.brushHead4280.textContent = 'N/A';
                }

                // Get Brush Head 42A2
                try {
                    const char42A2 = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_42A2);
                    const value42A2 = await char42A2.readValue();
                    if (value42A2.byteLength > 0) {
                        const hexArray = Array.from(new Uint8Array(value42A2.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushHead42A2.textContent = hexArray.join(', ');
                        log(`Brush Head 42A2: ${hexArray.join(', ')}`);
                    } else {
                        ui.brushHead42A2.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head 42A2 read error: ${e.message}`);
                    ui.brushHead42A2.textContent = 'N/A';
                }

                // Get Brush Head 42A4
                try {
                    const char42A4 = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_42A4);
                    const value42A4 = await char42A4.readValue();
                    if (value42A4.byteLength > 0) {
                        const hexArray = Array.from(new Uint8Array(value42A4.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushHead42A4.textContent = hexArray.join(', ');
                        log(`Brush Head 42A4: ${hexArray.join(', ')}`);
                    } else {
                        ui.brushHead42A4.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head 42A4 read error: ${e.message}`);
                    ui.brushHead42A4.textContent = 'N/A';
                }

                // Get Brush Head 42A6
                try {
                    const char42A6 = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_42A6);
                    const value42A6 = await char42A6.readValue();
                    if (value42A6.byteLength > 0) {
                        const hexArray = Array.from(new Uint8Array(value42A6.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushHead42A6.textContent = hexArray.join(', ');
                        log(`Brush Head 42A6: ${hexArray.join(', ')}`);
                    } else {
                        ui.brushHead42A6.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head 42A6 read error: ${e.message}`);
                    ui.brushHead42A6.textContent = 'N/A';
                }

                // Get Brush Head NFC URL (42B0)
                try {
                    const charNfcUrl = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_NFC_URL);
                    const valueNfcUrl = await charNfcUrl.readValue();
                    if (valueNfcUrl.byteLength > 0) {
                        const textValue = textDecoder.decode(valueNfcUrl).trim();
                        const hexArray = Array.from(new Uint8Array(valueNfcUrl.buffer))
                            .map(b => b.toString(16).padStart(2, '0').toUpperCase());
                        if (textValue.length > 0 && textValue.startsWith('https://')) {
                            // Create anchor element safely
                            const a = document.createElement('a');
                            a.href = textValue;
                            a.target = '_blank';
                            a.className = 'text-blue-400 hover:text-blue-300 underline';
                            a.textContent = textValue;
                            ui.brushHeadNfcUrl.textContent = ''; // Clear previous content
                            ui.brushHeadNfcUrl.appendChild(a);
                        } else {
                            ui.brushHeadNfcUrl.textContent = textValue.length > 0 ? `"${textValue}"` : `0x${hexArray.join('')}`;
                        }
                        log(`Brush Head NFC URL: "${textValue}" = 0x${hexArray.join('')}`);
                    } else {
                        ui.brushHeadNfcUrl.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head NFC URL read error: ${e.message}`);
                    ui.brushHeadNfcUrl.textContent = 'N/A';
                }

                // Get Brush Head 42C0
                try {
                    const char42C0 = await brushService.getCharacteristic(BLE.CHARS.BRUSH_HEAD_42C0);
                    const value42C0 = await char42C0.readValue();
                    if (value42C0.byteLength > 0) {
                        const hexArray = Array.from(new Uint8Array(value42C0.buffer))
                            .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                        ui.brushHead42C0.textContent = hexArray.join(', ');
                        log(`Brush Head 42C0: ${hexArray.join(', ')}`);
                    } else {
                        ui.brushHead42C0.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Brush Head 42C0 read error: ${e.message}`);
                    ui.brushHead42C0.textContent = 'N/A';
                }

                // Get Session ID (with error handling)
                try {
                    const sessionIdChar = await brushingService.getCharacteristic(BLE.CHARS.SESSION_ID);
                    const sessionIdValue = await sessionIdChar.readValue();
                    if (sessionIdValue.byteLength >= 2) {
                        ui.sessionId.textContent = sessionIdValue.getUint16(0, true);
                        log(`Session ID: ${sessionIdValue.getUint16(0, true)}`);
                    } else if (sessionIdValue.byteLength === 1) {
                        // Fallback: try single byte
                        ui.sessionId.textContent = sessionIdValue.getUint8(0);
                        log(`Session ID: ${sessionIdValue.getUint8(0)}`);
                    } else {
                        ui.sessionId.textContent = 'No data';
                        log(`Session ID: empty response`);
                    }
                } catch (e) {
                    log(`Session ID read error: ${e.message}`);
                    ui.sessionId.textContent = 'N/A';
                }

                // Get Active Time (with error handling)
                try {
                    const activeTimeChar = await brushingService.getCharacteristic(BLE.CHARS.ACTIVE_TIME);
                    const activeTimeValue = await activeTimeChar.readValue();
                    if (activeTimeValue.byteLength >= 1) {
                        const seconds = activeTimeValue.getUint8(0);
                        ui.activeTime.textContent = formatDuration(seconds);
                    } else {
                        ui.activeTime.textContent = 'No data';
                        log(`Active Time: empty response`);
                    }
                } catch (e) {
                    log(`Active Time read error: ${e.message}`);
                    ui.activeTime.textContent = 'Error reading';
                }

                // Get Strength (with error handling)
                try {
                    const strengthChar = await brushingService.getCharacteristic(BLE.CHARS.STRENGTH);
                    const strengthValue = await strengthChar.readValue();
                    if (strengthValue.byteLength >= 1) {
                        const strength = strengthValue.getUint8(0);
                        ui.strength.textContent = DATA_MAPS.STRENGTH[strength] || `Unknown (${strength})`;
                    } else {
                        ui.strength.textContent = 'No data';
                        log(`Strength: empty response`);
                    }
                } catch (e) {
                    log(`Strength read error: ${e.message}`);
                    ui.strength.textContent = 'Error reading';
                }

                // Get Routine Number
                try {
                    const routineNumberChar = await brushingService.getCharacteristic(BLE.CHARS.ROUTINE_NUMBER);
                    const routineNumberValue = await routineNumberChar.readValue();
                    if (routineNumberValue.byteLength >= 1) {
                        ui.routineNumber.textContent = routineNumberValue.getUint8(0);
                    } else {
                        ui.routineNumber.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Routine Number read error: ${e.message}`);
                    ui.routineNumber.textContent = 'N/A';
                }

                // Get Routine Length
                try {
                    const routineLengthChar = await brushingService.getCharacteristic(BLE.CHARS.ROUTINE_LENGTH);
                    const routineLengthValue = await routineLengthChar.readValue();
                    if (routineLengthValue.byteLength >= 2) {
                        const seconds = routineLengthValue.getUint16(0, true);
                        ui.routineLength.textContent = formatDuration(seconds);
                    } else if (routineLengthValue.byteLength >= 1) {
                        const seconds = routineLengthValue.getUint8(0);
                        ui.routineLength.textContent = formatDuration(seconds);
                    } else {
                        ui.routineLength.textContent = 'No data';
                    }
                } catch (e) {
                    log(`Routine Length read error: ${e.message}`);
                    ui.routineLength.textContent = 'N/A';
                }

                // --- Read Device Information Service ---
                try {
                    const deviceInfoService = await server.getPrimaryService(BLE.SERVICES.DEVICE_INFO);
                    const textDecoder2 = new TextDecoder('utf-8');

                    // Manufacturer Name
                    try {
                        const mfgChar = await deviceInfoService.getCharacteristic(BLE.CHARS.MANUFACTURER_NAME);
                        const mfgValue = await mfgChar.readValue();
                        ui.manufacturer.textContent = textDecoder2.decode(mfgValue).trim();
                    } catch (e) {
                        log(`Manufacturer read error: ${e.message}`);
                    }

                    // Model Number
                    try {
                        const modelChar = await deviceInfoService.getCharacteristic(BLE.CHARS.MODEL_NUMBER);
                        const modelValue = await modelChar.readValue();
                        ui.model.textContent = textDecoder2.decode(modelValue).trim();
                    } catch (e) {
                        log(`Model read error: ${e.message}`);
                    }

                    // Serial Number - BLOCKLISTED by browsers for security
                    // Cannot read 0x2a25 - browsers block this for privacy
                    // try {
                    //     const serialChar = await deviceInfoService.getCharacteristic(BLE.CHARS.SERIAL_NUMBER);
                    //     const serialValue = await serialChar.readValue();
                    //     ui.deviceSerial.textContent = textDecoder2.decode(serialValue).trim();
                    // } catch (e) {
                    //     log(`Serial read error: ${e.message}`);
                    // }
                    ui.deviceSerial.textContent = 'Blocked by browser';

                    // Firmware Revision
                    try {
                        const fwChar = await deviceInfoService.getCharacteristic(BLE.CHARS.FIRMWARE_REV);
                        const fwValue = await fwChar.readValue();
                        ui.firmware.textContent = textDecoder2.decode(fwValue).trim();
                    } catch (e) {
                        log(`Firmware read error: ${e.message}`);
                    }

                    // Hardware Revision
                    try {
                        const hwChar = await deviceInfoService.getCharacteristic(BLE.CHARS.HARDWARE_REV);
                        const hwValue = await hwChar.readValue();
                        const hwText = textDecoder2.decode(hwValue).trim();
                        ui.hardware.textContent = hwText.length > 0 ? hwText : 'N/A';
                    } catch (e) {
                        log(`Hardware read error: ${e.message}`);
                    }

                    // Software Revision
                    try {
                        const swChar = await deviceInfoService.getCharacteristic(BLE.CHARS.SOFTWARE_REV);
                        const swValue = await swChar.readValue();
                        const swText = textDecoder2.decode(swValue).trim();
                        ui.software.textContent = swText.length > 0 ? swText : 'N/A';
                    } catch (e) {
                        log(`Software read error: ${e.message}`);
                    }

                    // System ID
                    try {
                        const systemIdChar = await deviceInfoService.getCharacteristic(BLE.CHARS.SYSTEM_ID);
                        const systemIdValue = await systemIdChar.readValue();
                        if (systemIdValue.byteLength > 0) {
                            const hexArray = Array.from(new Uint8Array(systemIdValue.buffer))
                                .map(b => b.toString(16).padStart(2, '0').toUpperCase());
                            ui.systemId.textContent = '0x' + hexArray.join('');
                            log(`System ID: 0x${hexArray.join('')}`);
                        } else {
                            ui.systemId.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`System ID read error: ${e.message}`);
                        ui.systemId.textContent = 'N/A';
                    }

                    // IEEE 11073-20601 Regulatory Certification Data List
                    try {
                        const ieeeChar = await deviceInfoService.getCharacteristic(BLE.CHARS.IEEE_REGULATORY);
                        const ieeeValue = await ieeeChar.readValue();
                        if (ieeeValue.byteLength > 0) {
                            const hexArray = Array.from(new Uint8Array(ieeeValue.buffer))
                                .map(b => b.toString(16).padStart(2, '0').toUpperCase());
                            ui.ieeeRegulatory.textContent = '0x' + hexArray.join('');
                            log(`IEEE Regulatory: 0x${hexArray.join('')}`);
                        } else {
                            ui.ieeeRegulatory.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`IEEE Regulatory read error: ${e.message}`);
                        ui.ieeeRegulatory.textContent = 'N/A';
                    }

                    // PnP ID
                    try {
                        const pnpChar = await deviceInfoService.getCharacteristic(BLE.CHARS.PNP_ID);
                        const pnpValue = await pnpChar.readValue();
                        if (pnpValue.byteLength > 0) {
                            const hexArray = Array.from(new Uint8Array(pnpValue.buffer))
                                .map(b => b.toString(16).padStart(2, '0').toUpperCase());
                            
                            // Parse PnP ID structure (7 bytes):
                            // Byte 0: Vendor ID Source (0x01 = Bluetooth SIG)
                            // Bytes 1-2: Vendor ID (little-endian)
                            // Bytes 3-4: Product ID (little-endian)
                            // Bytes 5-6: Product Version (little-endian)
                            if (pnpValue.byteLength >= 7) {
                                const vendorSrc = pnpValue.getUint8(0);
                                const vendorId = pnpValue.getUint16(1, true);
                                const productId = pnpValue.getUint16(3, true);
                                const productVer = pnpValue.getUint16(5, true);
                                
                                const vendorSrcName = vendorSrc === 0x01 ? 'Bluetooth SIG' : vendorSrc === 0x02 ? 'USB' : 'Unknown';
                                ui.pnpId.textContent = `${vendorSrcName}: Vendor=${vendorId}, Product=${productId}, Ver=${productVer} (0x${hexArray.join('')})`;
                                log(`PnP ID: Source=${vendorSrcName}(${vendorSrc}), VID=0x${vendorId.toString(16)}, PID=0x${productId.toString(16)}, Ver=0x${productVer.toString(16)}`);
                            } else {
                                ui.pnpId.textContent = '0x' + hexArray.join('');
                            }
                        } else {
                            ui.pnpId.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`PnP ID read error: ${e.message}`);
                        ui.pnpId.textContent = 'N/A';
                    }

                } catch (e) {
                    log(`Device Info Service error: ${e.message}`);
                }

                // --- Read Diagnostic Service ---
                try {
                    const diagnosticService = await server.getPrimaryService(BLE.SERVICES.DIAGNOSTIC);

                    // Error Persistent
                    try {
                        const errorPersistentChar = await diagnosticService.getCharacteristic(BLE.CHARS.ERROR_PERSISTENT);
                        const errorPersistentValue = await errorPersistentChar.readValue();
                        if (errorPersistentValue.byteLength >= 3) {
                            // 20-bit integer (3 bytes)
                            const value = errorPersistentValue.getUint8(0) | 
                                          (errorPersistentValue.getUint8(1) << 8) | 
                                          ((errorPersistentValue.getUint8(2) & 0x0F) << 16);
                            ui.errorPersistent.textContent = value === 0 ? 'None (0)' : `0x${value.toString(16).toUpperCase()} (${value})`;
                        } else {
                            ui.errorPersistent.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`Error Persistent read error: ${e.message}`);
                        ui.errorPersistent.textContent = 'N/A';
                    }

                    // Error Volatile
                    try {
                        const errorVolatileChar = await diagnosticService.getCharacteristic(BLE.CHARS.ERROR_VOLATILE);
                        const errorVolatileValue = await errorVolatileChar.readValue();
                        if (errorVolatileValue.byteLength >= 3) {
                            // 20-bit integer (3 bytes)
                            const value = errorVolatileValue.getUint8(0) | 
                                          (errorVolatileValue.getUint8(1) << 8) | 
                                          ((errorVolatileValue.getUint8(2) & 0x0F) << 16);
                            ui.errorVolatile.textContent = value === 0 ? 'None (0)' : `0x${value.toString(16).toUpperCase()} (${value})`;
                        } else {
                            ui.errorVolatile.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`Error Volatile read error: ${e.message}`);
                        ui.errorVolatile.textContent = 'N/A';
                    }

                    // Proximity Value
                    try {
                        const proximityValueChar = await diagnosticService.getCharacteristic(BLE.CHARS.PROXIMITY_VALUE);
                        const proximityValue = await proximityValueChar.readValue();
                        if (proximityValue.byteLength > 0) {
                            const hexArray = Array.from(new Uint8Array(proximityValue.buffer))
                                .map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase());
                            ui.proximityValue.textContent = hexArray.join(', ');
                        } else {
                            ui.proximityValue.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`Proximity Value read error: ${e.message}`);
                        ui.proximityValue.textContent = 'N/A';
                    }

                    // Pressure Sensor
                    try {
                        const pressureSensorChar = await diagnosticService.getCharacteristic(BLE.CHARS.PRESSURE_SENSOR);
                        const pressureSensorValue = await pressureSensorChar.readValue();
                        if (pressureSensorValue.byteLength >= 2) {
                            const value = pressureSensorValue.getUint16(0, true);
                            ui.pressureSensor.textContent = value;
                        } else if (pressureSensorValue.byteLength >= 1) {
                            ui.pressureSensor.textContent = pressureSensorValue.getUint8(0);
                        } else {
                            ui.pressureSensor.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`Pressure Sensor read error: ${e.message}`);
                        ui.pressureSensor.textContent = 'N/A';
                    }

                    // Invalid Charger Count
                    try {
                        const invalidChargerCountChar = await diagnosticService.getCharacteristic(BLE.CHARS.INVALID_CHARGER_COUNT);
                        const invalidChargerCountValue = await invalidChargerCountChar.readValue();
                        if (invalidChargerCountValue.byteLength >= 2) {
                            const value = invalidChargerCountValue.getUint16(0, true);
                            ui.invalidChargerCount.textContent = value;
                        } else if (invalidChargerCountValue.byteLength >= 1) {
                            ui.invalidChargerCount.textContent = invalidChargerCountValue.getUint8(0);
                        } else {
                            ui.invalidChargerCount.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`Invalid Charger Count read error: ${e.message}`);
                        ui.invalidChargerCount.textContent = 'N/A';
                    }

                    // Debug Info
                    try {
                        const debugInfoChar = await diagnosticService.getCharacteristic(BLE.CHARS.DEBUG_INFO);
                        const debugInfoValue = await debugInfoChar.readValue();
                        const textDecoder = new TextDecoder('utf-8');
                        if (debugInfoValue.byteLength > 0) {
                            const debugText = textDecoder.decode(debugInfoValue).trim();
                            ui.debugInfo.textContent = debugText.length > 0 ? debugText : 'Empty';
                        } else {
                            ui.debugInfo.textContent = 'No data';
                        }
                    } catch (e) {
                        log(`Debug Info read error: ${e.message}`);
                        ui.debugInfo.textContent = 'N/A';
                    }

                } catch (e) {
                    log(`Diagnostic Service error: ${e.message}`);
                }

                log('Static data read successfully.');

                // --- Read Sensor Configuration (4120) ---
                try {
                    const orientationService = await server.getPrimaryService(BLE.SERVICES.ORIENTATION);

                    // Read 4120 - Sensor Configuration
                    try {
                        const char4120 = await orientationService.getCharacteristic(BLE.CHARS.ORIENTATION_CONFIG);
                        const value4120 = await char4120.readValue();
                        const bytes4120 = Array.from(new Uint8Array(value4120.buffer));

                        // Parse as 16-bit little-endian integer
                        const sensorConfigValue = value4120.getUint16(0, true);

                        // Display in UI
                        ui.sensorConfig.textContent = `${sensorConfigValue} (0x${sensorConfigValue.toString(16).padStart(4, '0')})`;

                        log(`üìä Sensor Config (4120): ${sensorConfigValue} = [${bytes4120.join(', ')}] (hex: ${bytes4120.map(b => b.toString(16).padStart(2, '0')).join(' ')})`);
                    } catch (e) {
                        ui.sensorConfig.textContent = 'N/A';
                        log(`‚ö†Ô∏è Sensor Config (4120): ${e.message}`);
                    }

                    // Try to read 4140 - Control characteristic (likely write-only)
                    try {
                        const char4140 = await orientationService.getCharacteristic(BLE.CHARS.ORIENTATION_CTRL);
                        const value4140 = await char4140.readValue();
                        const bytes4140 = Array.from(new Uint8Array(value4140.buffer));
                        log(`üìä Orientation Control (4140): ${bytes4140.length} bytes = [${bytes4140.join(', ')}] (hex: ${bytes4140.map(b => b.toString(16).padStart(2, '0')).join(' ')})`);
                    } catch (e) {
                        log(`‚ö†Ô∏è Orientation Control (4140): ${e.message} (likely write-only)`);
                    }
                } catch (e) {
                    log(`Orientation service exploration error: ${e.message}`);
                }

            } catch (error) {
                log(`Error reading static data: ${error.message}`);
            }
        }

        async function subscribeToNotifications() {
            log('Subscribing to notifications...');

            // Check if device is still connected
            if (!server || !server.connected) {
                throw new Error('Device disconnected before notifications could be subscribed');
            }

            // Log gyroscope capabilities info
            console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
            console.log(`‚ïë üì° SENSOR CAPABILITIES`);
            console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
            console.log(`‚ïë ‚úÖ 3-Axis GYROSCOPE (measures rotation rate)`);
            console.log(`‚ïë    ‚Ä¢ Gyro X: Rotation around X-axis (pitch rate)`);
            console.log(`‚ïë    ‚Ä¢ Gyro Y: Rotation around Y-axis (roll rate)`);
            console.log(`‚ïë    ‚Ä¢ Gyro Z: Rotation around Z-axis (yaw rate - spin around brush length)`);
            console.log(`‚ïë`);
            console.log(`‚ïë ‚úÖ 3-Axis ACCELEROMETER (measures gravity & acceleration)`);
            console.log(`‚ïë    ‚Ä¢ Used to determine brush orientation (pitch & roll)`);
            console.log(`‚ïë    ‚Ä¢ Scale: ¬±4g range (4096 LSB/g)`);
            console.log(`‚ïë`);
            console.log(`‚ïë ‚ùå NO MAGNETOMETER (compass)`);
            console.log(`‚ïë    ‚Ä¢ Cannot determine absolute heading/north direction`);
            console.log(`‚ïë    ‚Ä¢ Yaw (spin) is RELATIVE rotation only`);
            console.log(`‚ïë    ‚Ä¢ Yaw will drift over time (normal for gyro-only systems)`);
            console.log(`‚ïë`);
            console.log(`‚ïë üí° ROTATION TRACKING:`);
            console.log(`‚ïë    ‚Ä¢ Pitch & Roll: Accurate (from accelerometer)`);
            console.log(`‚ïë    ‚Ä¢ Yaw: Tracks spinning motion but has no absolute reference`);
            console.log(`‚ïë    ‚Ä¢ Use "Reset Yaw" button to zero out yaw drift`);
            console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

            try {
                // Gyroscope Data
                const orientationService = await server.getPrimaryService(BLE.SERVICES.ORIENTATION);
                const gyroChar = await orientationService.getCharacteristic(BLE.CHARS.GYRO_DATA);
                await gyroChar.startNotifications();
                gyroChar.addEventListener('characteristicvaluechanged', handleGyroData);
                log('Subscribed to Gyroscope (4130)');

                // Handle State (for live updates)
                const handleService = await server.getPrimaryService(BLE.SERVICES.HANDLE);
                const handleStateChar = await handleService.getCharacteristic(BLE.CHARS.HANDLE_STATE);
                await handleStateChar.startNotifications();
                handleStateChar.addEventListener('characteristicvaluechanged', (e) => updateHandleState(e.target.value));
                log('Subscribed to Handle State (4010)');

                // Session State (for live updates)
                const brushingService = await server.getPrimaryService(BLE.SERVICES.BRUSHING);
                const sessionStateChar = await brushingService.getCharacteristic(BLE.CHARS.SESSION_STATE);
                await sessionStateChar.startNotifications();
                sessionStateChar.addEventListener('characteristicvaluechanged', (e) => updateSessionState(e.target.value));
                log('Subscribed to Session State (4082)');

                // Mode (for live updates when you change it on brush)
                const modeChar = await brushingService.getCharacteristic(BLE.CHARS.MODE);
                await modeChar.startNotifications();
                modeChar.addEventListener('characteristicvaluechanged', (e) => updateMode(e.target.value));
                log('Subscribed to Mode (4080)');

                // Active Time (for live updates)
                const activeTimeChar = await brushingService.getCharacteristic(BLE.CHARS.ACTIVE_TIME);
                await activeTimeChar.startNotifications();
                activeTimeChar.addEventListener('characteristicvaluechanged', (e) => {
                    const seconds = e.target.value.getUint8(0);
                    ui.activeTime.textContent = formatDuration(seconds);
                });
                log('Subscribed to Active Time (4090)');

                // Strength (for live updates)
                const strengthChar = await brushingService.getCharacteristic(BLE.CHARS.STRENGTH);
                await strengthChar.startNotifications();
                strengthChar.addEventListener('characteristicvaluechanged', (e) => {
                    const strength = e.target.value.getUint8(0);
                    ui.strength.textContent = DATA_MAPS.STRENGTH[strength] || `Unknown (${strength})`;
                });
                log('Subscribed to Strength (40b0)');

            } catch (error) {
                log(`Error subscribing to notifications: ${error.message}`);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DATA UPDATE FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function updateHandleState(dataView) {
            const state = dataView.getUint8(0);
            ui.handleState.textContent = DATA_MAPS.HANDLE_STATE[state] || `Unknown (${state})`;
        }
        
        function updateMode(dataView) {
            const mode = dataView.getUint8(0);
            ui.mode.textContent = DATA_MAPS.BRUSHING_MODE[mode] || `Unknown (0x${mode.toString(16)})`;
        }

        function updateSessionState(dataView) {
            const state = dataView.getUint8(0);
            ui.sessionState.textContent = DATA_MAPS.SESSION_STATE[state] || `Unknown (${state})`;
        }

        function handleGyroData(event) {
            const dataView = event.target.value;
            const len = dataView.byteLength;

            // DEBUG: Dump raw packet (first time only for each length)
            if (!window.packetDumped || !window.packetDumped[len]) {
                window.packetDumped = window.packetDumped || {};
                window.packetDumped[len] = true;
                const bytes = [];
                for (let i = 0; i < len; i++) {
                    bytes.push(dataView.getUint8(i).toString(16).padStart(2, '0'));
                }
                console.log(`üîç RAW PACKET (${len} bytes):`);
                if (len === 16) {
                    console.log(`   [0-5]  Gyro:    ${bytes.slice(0, 6).join(' ')}`);
                    console.log(`   [6-9]  Unknown: ${bytes.slice(6, 10).join(' ')}`);
                    console.log(`   [10-15] Accel:   ${bytes.slice(10, 16).join(' ')}`);
                } else if (len === 12) {
                    console.log(`   [0-5]  Gyro:  ${bytes.slice(0, 6).join(' ')}`);
                    console.log(`   [6-11] Accel: ${bytes.slice(6, 12).join(' ')}`);
                } else {
                    console.log(`   ${bytes.join(' ')}`);
                }
            }

            // DEBUG: On-demand detailed packet dump
            if (window.debugNextPacket && len >= 12) {
                window.debugNextPacket = false;
                console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                console.log(`‚ïë üî¨ DETAILED PACKET ANALYSIS (${len} bytes)`);
                console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

                // Hex dump
                const hexBytes = [];
                for (let i = 0; i < len; i++) {
                    hexBytes.push(dataView.getUint8(i).toString(16).padStart(2, '0'));
                }
                console.log(`‚ïë HEX: ${hexBytes.join(' ')}`);
                console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

                // All possible 16-bit interpretations
                console.log(`‚ïë ALL 16-bit INTERPRETATIONS (little-endian signed):`);
                for (let offset = 0; offset <= len - 2; offset += 2) {
                    const val = dataView.getInt16(offset, true);
                    const scaledAccel = (val / 4096.0).toFixed(4);  // ¬±4g range
                    const scaledAlt = (val / 16384.0).toFixed(4);   // ¬±2g range (for comparison)
                    console.log(`‚ïë   [${offset.toString().padStart(2)}]: ${val.toString().padStart(6)} ‚Üí ${scaledAccel}g (√∑4096) OR ${scaledAlt}g (√∑16384)`);
                }
                console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                console.log(`‚ïë LOOKING FOR: ¬±4096 (¬±1g vertical at ¬±4g range) when standing upright`);
                console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
            }

            // The gyro data can have different lengths:
            // - 6 bytes: Likely gyro only (3x int16)
            // - 7 bytes: Gyro (6 bytes) + 1 status byte
            // - 12 bytes: Gyro + Accel (6x int16)
            // - 16 bytes: Gyro + Accel + extra data (timestamp/counter)

            let gyroX = 0, gyroY = 0, gyroZ = 0;
            let accX = lastAccX, accY = lastAccY, accZ = lastAccZ; // Use last known values

            if (len >= 6) {
                // Always read gyro data (first 6 bytes)
                gyroX = dataView.getInt16(0, true);
                gyroY = dataView.getInt16(2, true);
                gyroZ = dataView.getInt16(4, true);
            }

            if (len >= 12) {
                // Read accelerometer data if available
                // IMPORTANT: 16-byte packets have different structure than 12-byte!
                if (len === 16) {
                    // Hypothesis: 16-byte = [gyro(6)][unknown(4)][accel(6)]
                    // Reading from bytes 10-15 instead of 6-11
                    accX = dataView.getInt16(10, true);
                    accY = dataView.getInt16(12, true);
                    accZ = dataView.getInt16(14, true);

                    // DEBUG: Show what's at old position (once)
                    if (!window.showedAltPosition) {
                        window.showedAltPosition = true;
                        const oldX = dataView.getInt16(6, true);
                        const oldY = dataView.getInt16(8, true);
                        const oldZ = dataView.getInt16(10, true);
                        console.log(`üîç TESTING: 16-byte packet structure`);
                        console.log(`   Position 6-11: X=${oldX}, Y=${oldY}, Z=${oldZ}`);
                        console.log(`   Position 10-15: X=${accX}, Y=${accY}, Z=${accZ}`);
                        console.log(`   Expected: one axis ‚âà ¬±16384 for vertical orientation`);
                    }
                } else {
                    // 12-byte packets use standard position
                    accX = dataView.getInt16(6, true);
                    accY = dataView.getInt16(8, true);
                    accZ = dataView.getInt16(10, true);
                }

                // Store for future packets
                lastAccX = accX;
                lastAccY = accY;
                lastAccZ = accZ;

                // Log packet type occasionally
                if (!window.lastPacketLog || (Date.now() - window.lastPacketLog) > 5000) {
                    window.lastPacketLog = Date.now();
                    console.log(`‚úÖ Receiving ${len}-byte packets with ACCELEROMETER data`);
                }
            } else {
                // No accelerometer in this packet - use last known values
                if (!window.lastPacketLog || (Date.now() - window.lastPacketLog) > 5000) {
                    window.lastPacketLog = Date.now();
                    console.log(`‚ö†Ô∏è Receiving ${len}-byte packets WITHOUT accelerometer (gyro only) - using last known accel`);
                }
            }

            if (len === 7) {
                // 7-byte format: 6 bytes gyro + 1 byte status/counter
                // The 7th byte might be a packet counter or status flag
                // const statusByte = dataView.getUint8(6);
            }

            if (len === 16) {
                // 16-byte format: might have extra data (timestamp? counter?)
                // For now, we'll just use the first 12 bytes as gyro+accel
                // and ignore bytes 12-15
                // You can log them for debugging:
                // const extra = dataView.getUint32(12, true);
                // console.log('Extra data:', extra);
            }

            if (len !== 6 && len !== 7 && len !== 12 && len !== 16) {
                // Only log truly unexpected lengths
                log(`Unexpected gyro data length: ${len}`);
                return;
            }

            // Debug: Log sensor values periodically (every 2 seconds)
            const now = Date.now();
            if (!window.lastSensorLog || (now - window.lastSensorLog) > 2000) {
                window.lastSensorLog = now;

                // Log gyroscope values
                console.log(`üîÑ GYRO RAW: X=${gyroX}, Y=${gyroY}, Z=${gyroZ}`);
                console.log(`   ‚Ä¢ Gyro Z (spin around brush): ${gyroZ} ${Math.abs(gyroZ) > 50 ? 'üåÄ ROTATING!' : '(stationary)'}`);

                // Log accelerometer if available
                if (len >= 12) {
                    const accX_g = accX * CONFIG.ACCEL_SCALE;
                    const accY_g = accY * CONFIG.ACCEL_SCALE;
                    const accZ_g = accZ * CONFIG.ACCEL_SCALE;
                    const mag = Math.sqrt(accX_g**2 + accY_g**2 + accZ_g**2);
                    console.log(`üìä ACCEL RAW: X=${accX}, Y=${accY}, Z=${accZ}`);
                    console.log(`üìä ACCEL SCALED: X=${accX_g.toFixed(3)}g, Y=${accY_g.toFixed(3)}g, Z=${accZ_g.toFixed(3)}g, |mag|=${mag.toFixed(3)}g`);
                    console.log(`üìä Expected: When vertical, one axis ‚âà ¬±1g, magnitude ‚âà 1g`);
                }
            }

            // Update the graph
            updateChart(gyroX, gyroY, gyroZ, accX, accY, accZ);

            // Update the 3D model
            update3DModel(gyroX, gyroY, gyroZ, accX, accY, accZ, event.timeStamp);
        }

        function updateChart(gx, gy, gz, ax, ay, az) {
            const label = new Date().toLocaleTimeString();
            sensorChart.data.labels.push(label);
            sensorChart.data.datasets[0].data.push(gx);
            sensorChart.data.datasets[1].data.push(gy);
            sensorChart.data.datasets[2].data.push(gz);
            sensorChart.data.datasets[3].data.push(ax);
            sensorChart.data.datasets[4].data.push(ay);
            sensorChart.data.datasets[5].data.push(az);

            // Limit data points to 100
            if (sensorChart.data.labels.length > 100) {
                sensorChart.data.labels.shift();
                sensorChart.data.datasets.forEach(dataset => dataset.data.shift());
            }

            // Throttle chart updates to reduce unnecessary redraws (100ms intervals)
            const now = Date.now();
            if (!window.lastChartUpdate || (now - window.lastChartUpdate) >= 100) {
                sensorChart.update();
                window.lastChartUpdate = now;
            }
        }
        
        /**
         * Update 3D model from sensor data
         * Combines accelerometer (pitch/roll) with gyroscope (yaw/spin)
         */
        function update3DModel(gyroX, gyroY, gyroZ, accX, accY, accZ, timestamp) {
            if (!toothbrushMesh) return;

            // Initialize timestamp on first call
            if (!lastTimestamp) {
                lastTimestamp = timestamp;
                return;
            }

            const deltaTime = (timestamp - lastTimestamp) / 1000.0; // in seconds
            lastTimestamp = timestamp;
            
            // Convert accelerometer values from sensor units to g-force using CONFIG
            const accX_g = accX * CONFIG.ACCEL_SCALE;      // Sensor X in g-force
            const accY_g = accY * CONFIG.ACCEL_SCALE;      // Sensor Y in g-force (brush length)
            const accZ_g = accZ * CONFIG.ACCEL_SCALE;      // Sensor Z in g-force

            // Update coordinate display
            updateCoordinateDebug(accX, accY, accZ, accX_g, accY_g, accZ_g);

            // 1. Process gyroscope rotation (Z-axis spin around brush length)
            processGyroscopeRotation(gyroZ, deltaTime);

            // 2. Update brush orientation from accelerometer (pitch & roll)
            updateBrushOrientation(accX_g, accY_g, accZ_g);
        }

        /**
         * Update the coordinate debug display with real-world and Three.js coordinates
         * Throttled to reduce DOM updates
         */
        function updateCoordinateDebug(rawX, rawY, rawZ, worldX, worldY, worldZ) {
            // Only update debug display every 200ms (debug info doesn't need to be real-time)
            const now = Date.now();
            if (!window.lastDebugUpdate || (now - window.lastDebugUpdate) > 200) {
                // Cache DOM elements
                if (!window.debugElementsCache) {
                    window.debugElementsCache = {
                        realX: document.getElementById('real-x'),
                        realY: document.getElementById('real-y'),
                        realZ: document.getElementById('real-z'),
                        threejsX: document.getElementById('threejs-x'),
                        threejsY: document.getElementById('threejs-y'),
                        threejsZ: document.getElementById('threejs-z'),
                        debugPitch: document.getElementById('debug-pitch'),
                        debugRoll: document.getElementById('debug-roll'),
                        debugYaw: document.getElementById('debug-yaw'),
                    };
                }
                
                const cache = window.debugElementsCache;
                
                // Real-world (sensor) coordinates in g - use CONFIG.ACCEL_SCALE
                if (cache.realX) cache.realX.textContent = (rawX * CONFIG.ACCEL_SCALE).toFixed(3);
                if (cache.realY) cache.realY.textContent = (rawY * CONFIG.ACCEL_SCALE).toFixed(3);
                if (cache.realZ) cache.realZ.textContent = (rawZ * CONFIG.ACCEL_SCALE).toFixed(3);

                // Three.js world coordinates (already in g)
                if (cache.threejsX) cache.threejsX.textContent = worldX.toFixed(3);
                if (cache.threejsY) cache.threejsY.textContent = worldY.toFixed(3);
                if (cache.threejsZ) cache.threejsZ.textContent = worldZ.toFixed(3);

                // Rotation values (already displayed elsewhere, but update debug too)
                if (cache.debugPitch) cache.debugPitch.textContent = ui.pitch.textContent;
                if (cache.debugRoll) cache.debugRoll.textContent = ui.roll.textContent;
                if (cache.debugYaw) cache.debugYaw.textContent = ui.yaw.textContent;
                
                window.lastDebugUpdate = now;
            }
        }


    </script>
</body>
</html>